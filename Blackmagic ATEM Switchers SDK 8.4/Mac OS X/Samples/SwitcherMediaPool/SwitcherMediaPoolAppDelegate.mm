/* -LICENSE-START-
** Copyright (c) 2012 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#import "SwitcherMediaPoolAppDelegate.h"
#include "MediaPoolTransfer.h"
#include "CallbackMonitors.h"
#include <libkern/OSAtomic.h>
#include <string>

@implementation SwitcherMediaPoolAppDelegate

@synthesize window;

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
	mSwitcherDiscovery = CreateBMDSwitcherDiscoveryInstance();
	if (! mSwitcherDiscovery)
	{
		NSAlert* alert = [[NSAlert alloc] init];
		[alert setMessageText:@"Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed.\n"];
		[alert addButtonWithTitle:@"OK"];
		[alert beginSheetModalForWindow:window completionHandler:^(NSModalResponse returnCode) {
			[NSApp terminate:self];
		}];
	}
	
	mSwitcher = NULL;
	mMediaPool = NULL;
	mStills = NULL;
	mSwitcherMonitor = new SwitcherMonitor(self);
	mMediaPlayer1Monitor = new MediaPlayerMonitor(self);
	mStillsMonitor = new StillsMonitor(self);
	mStillTransfer = NULL;
	
	[self switcherDisconnected];		// start with switcher disconnected
}

- (void)applicationWillTerminate:(NSNotification*)aNotification
{
	[self cleanUpConnection];
	
	delete mMediaPlayer1Monitor;
	mMediaPlayer1Monitor = NULL;
	
	delete mStillsMonitor;
	mStillsMonitor = NULL;
	
	delete mSwitcherMonitor;
	mSwitcherMonitor = NULL;
	
	if (mSwitcherDiscovery)
	{
		mSwitcherDiscovery->Release();
		mSwitcherDiscovery = NULL;
	}
}

- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication*)sender
{
	return YES;
}

//
// Actions
//

- (IBAction)connectButtonClicked:(id)sender
{
	BMDSwitcherConnectToFailure failReason;
	NSString* address = [mAddressText stringValue];
	
	// ensure we have cleaned up an existing connection
	[self cleanUpConnection];
	
	// Note that ConnectTo() can take several seconds to return, both for success or failure,
	// depending upon hostname resolution and network response times, so it may be best to
	// do this in a separate thread to prevent the main GUI thread blocking.
	HRESULT hr = mSwitcherDiscovery->ConnectTo((CFStringRef)address, &mSwitcher, &failReason);
	if (SUCCEEDED(hr))
	{
		[self switcherConnected];
	}
	else
	{
		NSString* reason;
		switch (failReason)
		{
			case bmdSwitcherConnectToFailureNoResponse:
				reason = @"No response from Switcher";
				break;
			case bmdSwitcherConnectToFailureIncompatibleFirmware:
				reason = @"Switcher has incompatible firmware";
				break;
			default:
				reason = @"Connection failed for unknown reason";
		}
		NSAlert* alert = [[NSAlert alloc] init];
		[alert setMessageText:reason];
		[alert addButtonWithTitle:@"OK"];
		[alert beginSheetModalForWindow:window completionHandler:nullptr];
	}
}

- (IBAction)mediaPlayerSourcePopupChanged:(id)sender
{
	HRESULT result;
	uint32_t clipCount;
	BMDSwitcherMediaPlayerSourceType sourceType;
	int sourceIndex;
	uint32_t comboIndex = [mMediaPlayerSourcePopup indexOfSelectedItem];
	
	// check we have the media pool
	if (! mMediaPool)
	{
		NSLog(@"No media pool\n");
		return;
	}
	
	// get the clip count
	result = mMediaPool->GetClipCount(&clipCount);
	if (FAILED(result))
	{
		NSLog(@"Could not get clip count\n");
		return;
	}
	
	// determine if source is clip or still
	if (comboIndex < clipCount)
	{
		// source is a clip
		sourceType = bmdSwitcherMediaPlayerSourceTypeClip;
		sourceIndex = comboIndex;
	}
	else
	{
		// source is a still
		sourceType = bmdSwitcherMediaPlayerSourceTypeStill;
		sourceIndex = comboIndex - clipCount;
	}
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// set media player 1 source
	result = mMediaPlayers[0]->SetSource(sourceType, sourceIndex);
	if (FAILED(result))
	{
		NSLog(@"Could not set media player 1 source\n");
		return;
	}
}

- (IBAction)beginButtonClicked:(id)sender
{
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// toggle the 'at beginning' property, the button state will change upon notification from the switcher
	HRESULT result = mMediaPlayers[0]->SetAtBeginning();
	if (FAILED(result))
	{
		NSLog(@"Could not set 'at beginning'\n");
		return;
	}
}

- (IBAction)previousButtonClicked:(id)sender
{
	HRESULT result;
	uint32_t clipFrameIndex;
	uint32_t clipIndex = [mMediaPlayerSourcePopup indexOfSelectedItem];
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// check we have the clip
	if (clipIndex > mClips.size())
	{
		NSLog(@"No valid clip selected\n");
		return;
	}
	
	// get the clip frame index
	result = mMediaPlayers[0]->GetClipFrame(&clipFrameIndex);
	if (FAILED(result))
	{
		NSLog(@"Could not get clip frame index\n");
		return;
	}
	
	// we can't goto the previous frame if we are on the first frame
	if (clipFrameIndex > 0)
	{
		// set clip frame index to previous frame
		result = mMediaPlayers[0]->SetClipFrame(clipFrameIndex - 1);
		if (FAILED(result))
		{
			NSLog(@"Could not set clip frame index\n");
			return;
		}
	}
}

- (IBAction)playButtonClicked:(id)sender
{
	HRESULT result;
	bool playing;
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// get the playing property
	result = mMediaPlayers[0]->GetPlaying(&playing);
	if (FAILED(result))
	{
		NSLog(@"Could not get playing\n");
		return;
	}
	
	// toggle the playing property, the button state will change upon notification from the switcher
	result = mMediaPlayers[0]->SetPlaying(! playing);
	if (FAILED(result))
	{
		NSLog(@"Could not set playing\n");
		return;
	}
}

- (IBAction)nextButtonClicked:(id)sender
{
	HRESULT result;
	uint32_t clipFrameCount;
	uint32_t clipFrameIndex;
	uint32_t clipIndex = [mMediaPlayerSourcePopup indexOfSelectedItem];
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// check we have the clip
	if (clipIndex > mClips.size())
	{
		NSLog(@"No valid clip selected\n");
		return;
	}
	
	// check we have the clip
	result = mClips[clipIndex]->GetFrameCount(&clipFrameCount);
	if (FAILED(result))
	{
		NSLog(@"Could not get clip frame count\n");
		return;
	}
	
	// get the clip frame index
	result = mMediaPlayers[0]->GetClipFrame(&clipFrameIndex);
	if (FAILED(result))
	{
		NSLog(@"Could not get clip frame index\n");
		return;
	}
	
	// we can't goto the next frame if we are on the last frame
	if (++clipFrameIndex < clipFrameCount)
	{
		// set clip frame index to previous frame
		result = mMediaPlayers[0]->SetClipFrame(clipFrameIndex);
		if (FAILED(result))
		{
			NSLog(@"Could not set clip frame index\n");
			return;
		}
	}
}

- (IBAction)loopButtonClicked:(id)sender
{
	HRESULT result;
	bool loop;
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// get the loop property
	result = mMediaPlayers[0]->GetLoop(&loop);
	if (FAILED(result))
	{
		NSLog(@"Could not get loop\n");
		return;
	}
	
	// toggle the loop property, the button state will change upon notification from the switcher
	result = mMediaPlayers[0]->SetLoop(! loop);
	if (FAILED(result))
	{
		NSLog(@"Could not set loop\n");
		return;
	}
}

- (IBAction)mediaPoolTargetPopupChanged:(id)sender
{
	// the media pool combo box selected item has changed
	[self updateMediaPoolPopupSelection];
}

- (IBAction)uploadButtonClicked:(id)sender
{
	int comboIndex = [mMediaPoolTargetPopup indexOfSelectedItem];
	bool uploadStarted = false;
	
	// disable the upload button immediately to prevent additional clicks
	[mMediaPoolUploadButton setEnabled:NO];
	
	// determine if the upload target is a still or clip
	if (comboIndex < mClips.size())
	{
		// target is a clip
		
		if (comboIndex >= mClipTransfers.size())
		{
			NSLog(@"No clip transfer for this clip index\n");
			return;
		}
		
		// open dialog
		NSOpenPanel* openDlg = [NSOpenPanel openPanel];
		
		// clips can have one or more frames
		[openDlg setAllowsMultipleSelection:YES];
		
		// in this example application we only support tga files and we do not support the full tga specification
		// this means that some tga files will not be uploadable
		[openDlg setAllowedFileTypes:[NSArray arrayWithObject:@"tga"]];
		
		if ([openDlg runModal] == NSFileHandlingPanelOKButton)
		{
			// the user has selected at least one file and has clicked the open button
			std::list<std::string> filePaths;
			
			// the user has clicked OK
			for (NSURL* url in [openDlg URLs])
			{
				std::string filePath([[url path] cStringUsingEncoding: NSASCIIStringEncoding]);
				filePaths.push_back(filePath);
			}
			
			// start progress as the upload method can block for a short time
			[mMediaPoolProgressIndicator startAnimation:self];
			
			// upload the file selected by the user to the still
			uploadStarted = mClipTransfers[comboIndex]->upload(filePaths);
		}
	}
	else
	{
		// target is a still
		
		if (! mStillTransfer)
		{
			NSLog(@"No still transfer\n");
			return;
		}
		
		// open dialog
		NSOpenPanel* openDlg = [NSOpenPanel openPanel];
		
		// in this example application we only support tga files and we do not support the full tga specification
		// this means that some tga files will not be uploadable
		[openDlg setAllowedFileTypes:[NSArray arrayWithObject:@"tga"]];
		
		if ([openDlg runModal] == NSFileHandlingPanelOKButton)
		{
			// the user has clicked OK
			NSURL* url = [openDlg URL];
			std::string filePath([[url path] cStringUsingEncoding: NSASCIIStringEncoding]);
			
			// start progress as the upload method can block for a short time
			[mMediaPoolProgressIndicator startAnimation:self];
			
			// upload the file selected by the user to the still
			uploadStarted = mStillTransfer->upload(comboIndex - mClips.size(), filePath);
		}
	}

	if (! uploadStarted)
	{
		// upload failed to start
		[mMediaPoolUploadButton setEnabled:YES];			// re-enable the upload button
		[mMediaPoolProgressIndicator stopAnimation:self];	// stop progress
	}
}

//
// Monitor Callbacks
//

- (void)onSwitcherDisconnected
{
	// the switcher has disconnected
	
	[self switcherDisconnected];
}

- (void)onMediaPlayerSourceChanged
{
	// the source has changed
	
	// update the selected source
	[self updateMediaPlayerPopupSelection];
}

- (void)onMediaPlayerPlayingChanged
{
	// the switcher has notified us that the playing property has changed
	
	bool playing;
	HRESULT result;
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// get the playing property
	result = mMediaPlayers[0]->GetPlaying(&playing);
	if (FAILED(result))
	{
		NSLog(@"Could not get playing\n");
		return;
	}
	
	// update the state of the button
	[mMediaPlayerPlayButton setState:playing];
}

- (void)onMediaPlayerBeginChanged
{
	// the switcher has notified us that the 'at beginning' property has changed
	
	bool atBegining;
	HRESULT result;
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// get the 'at beginning' property
	result = mMediaPlayers[0]->GetAtBeginning(&atBegining);
	if (FAILED(result))
	{
		NSLog(@"Could not get 'at beginning'\n");
		return;
	}
	
	// update the state of the button
	[mMediaPlayerBeginButton setState:atBegining];
}

- (void)onMediaPlayerLoopChanged
{
	// the switcher has notified us that the loop property has changed
	
	bool loop;
	HRESULT result;
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// get the loop property
	result = mMediaPlayers[0]->GetLoop(&loop);
	if (FAILED(result))
	{
		NSLog(@"Could not get loop\n");
		return;
	}
	
	// update the state of the button
	[mMediaPlayerLoopButton setState:loop];
}

- (void)onStillClipNameValidChanged
{
	// We could update only the item that has changed, but this is simpler
	[self updateMediaPopupItems:mMediaPlayerSourcePopup];
	[self updateMediaPlayerPopupSelection];
	[self updateMediaPopupItems:mMediaPoolTargetPopup];
	[self updateMediaPoolPopupSelection];
}

- (void)onStillsLockObtained
{
	// lock has been obtained on stills
	
	if (mStillTransfer)
	{
		// pass the message through to the still transfer
		mStillTransfer->onLockObtained();
	}
}

- (void)onClipLockObtained:(NSNumber *)clipIndex
{
	// lock has been obtained on a clip
	
	int clipIndexInt = [clipIndex intValue];
	
	if (clipIndexInt < (int)mClips.size())
	{
		// pass the message through to the clip transfer
		mClipTransfers[clipIndexInt]->onLockObtained();
	}
}

- (void)onStillsTransferEnded:(NSNumber *)enabled
{
	// a still transfer has ended
	BOOL success = [enabled boolValue];
	
	if (! mStillTransfer)
	{
		NSLog(@"No still transfer interface\n");
		return;
	}
	
	// pass message through to the still transfer
	mStillTransfer->onTransferEnded(success);
	
	// enable the upload button now that the transfer has ended
	[mMediaPoolUploadButton setEnabled:YES];
	
	// stop the progress indicator
	[mMediaPoolProgressIndicator stopAnimation:self];
}

- (void)onClipTransferEnded:(NSArray *)args
{
	// a still transfer has ended
	BOOL success = [[args objectAtIndex:0] boolValue];
	int clipIndexInt = [[args objectAtIndex:1] intValue];
	
	if (clipIndexInt >= (int)mClips.size())
	{
		NSLog(@"No clip interface for clip index\n");
		return;
	}
	
	// pass message through to the clip transfer
	if (mClipTransfers[clipIndexInt]->onTransferEnded(success))
	{
		// enable the upload button now that the transfer has ended
		[mMediaPoolUploadButton setEnabled:YES];
		
		// stop the progress indicator
		[mMediaPoolProgressIndicator stopAnimation:self];
	}
}

//
// Helper Methods
//

- (void)cleanUpConnection
{
	// disconnect monitors
	mSwitcherMonitor->setSwitcher(NULL);
	mMediaPlayer1Monitor->setMediaPlayer(NULL);
	mStillsMonitor->setStills(NULL);
	
	// we delete clip monitors because they
	// are created and set on every connection
	while (mClipMonitors.size())
	{
		delete mClipMonitors.back();
		mClipMonitors.pop_back();
	}
	
	// free connected switcher interfaces
	
	while (mMediaPlayers.size())
	{
		mMediaPlayers.back()->Release();
		mMediaPlayers.pop_back();
	}
	
	while (mClips.size())
	{
		mClips.back()->Release();
		mClips.pop_back();
	}
	
	if (mStills)
	{
		mStills->Release();
		mStills = NULL;
	}
	
	if (mMediaPool)
	{
		mMediaPool->Release();
		mMediaPool = NULL;
	}
	
	if (mSwitcher)
	{
		mSwitcher->Release();
		mSwitcher = NULL;
	}
	
	// free still transfer
	delete mStillTransfer;
	mStillTransfer = NULL;
	
	// free clip transfers
	while (mClipTransfers.size())
	{
		delete mClipTransfers.back();
		mClipTransfers.pop_back();
	}
}

- (void)switcherConnected
{
	HRESULT result;
	REFIID mediaPoolIID = IID_IBMDSwitcherMediaPool;
	IBMDSwitcherMediaPlayerIterator* mediaPlayerIterator = NULL;
	uint32_t clipCount;
	
	// update UI enabled states
	[mConnectButton setEnabled:NO];	// disable Connect button while connected
	[mMediaPlayerSourcePopup setEnabled:YES];
	[self enableMediaPlayerButtons:true];
	[self enableMediaPoolWidgets:true];
	
	// get the product name
	NSString* productName = NULL;
	if (FAILED(mSwitcher->GetProductName((CFStringRef*)&productName)))
	{
		NSLog(@"Could not get switcher product name\n");
		return;
	}
	
	// set the product name for the UI
	[mNameText setStringValue:productName];
	[productName release];
	
	// get the media player iterator
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherMediaPlayerIterator, (void**)&mediaPlayerIterator);
	if (FAILED(result))
	{
		NSLog(@"Could not create IBMDSwitcherMediaPlayerIterator iterator\n");
		goto finish;
	}
	
	// get all media players
	while (true)
	{
		IBMDSwitcherMediaPlayer* mediaPlayer = NULL;
		result = mediaPlayerIterator->Next(&mediaPlayer);
		if (result != S_OK)
			break;
		
		mMediaPlayers.push_back(mediaPlayer);
	}
	
	if (FAILED(result))
	{
		NSLog(@"Could not iterate media players\n");
		goto finish;
	}
	
	// get media pool
	result = mSwitcher->QueryInterface(mediaPoolIID, (void**)&mMediaPool);
	if (FAILED(result))
	{
		NSLog(@"Could not get IBMDSwitcherMediaPool interface\n");
		goto finish;
	}
	
	// get stills interface
	result = mMediaPool->GetStills(&mStills);
	if (FAILED(result))
	{
		NSLog(@"Could not get IBMDSwitcherStills interface\n");
		goto finish;
	}
	
	// get number of clips
	result = mMediaPool->GetClipCount(&clipCount);
	if (FAILED(result))
	{
		NSLog(@"Could not get clip count\n");
		goto finish;
	}
	
	// get all clip interfaces
	for (unsigned long clipIndex = 0; clipIndex < clipCount; ++clipIndex)
	{
		IBMDSwitcherClip* clip = NULL;
		
		result = mMediaPool->GetClip(clipIndex, &clip);
		if (FAILED(result))
		{
			NSLog(@"Could not get clip interface\n");
			goto finish;
		}
		
		mClips.push_back(clip);
	}
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		goto finish;
	}
	
	// set monitors, which will flush the callbacks and update the GUI
	mSwitcherMonitor->setSwitcher(mSwitcher);
	mMediaPlayer1Monitor->setMediaPlayer(mMediaPlayers[0]);
	mStillsMonitor->setStills(mStills);
	
	if (mClipMonitors.size() > 0)
		NSLog(@"Clip monitors have not been deleted\n");
	
	// create clip monitors here because we don't know clip count on initialization
	for (unsigned long clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
	{
		ClipMonitor* clipMonitor = new ClipMonitor(self);
		clipMonitor->setClip(mClips[clipIndex]);
		mClipMonitors.push_back(clipMonitor);
	}
	
	// create still transfer
	mStillTransfer = new StillTransfer(self, window, mSwitcher, mMediaPool, mStills);
	
	// create clip transfers
	for (unsigned long clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
	{
		ClipTransfer* clipTransfer = new ClipTransfer(self, window, mSwitcher, mMediaPool, mClips[clipIndex]);
		mClipTransfers.push_back(clipTransfer);
	}
	
finish:
	if (mediaPlayerIterator)
		mediaPlayerIterator->Release();
}

- (void)switcherDisconnected
{
	[self enableMediaPlayerButtons:false];
	[self enableMediaPoolWidgets:false];
	[self cleanUpConnection];
	[mConnectButton setEnabled:YES]; // enable connect button so user can re-connect
	[mMediaPlayerSourcePopup setEnabled:NO];
	
	[mNameText setStringValue:@""];
}

- (void)updateMediaPopupItems:(NSPopUpButton*)comboBox;
{
	HRESULT result;
	uint32_t stillCount;
	int comboIndex = [comboBox indexOfSelectedItem]; // save current index
	
	// check we have the media pool
	if (! mMediaPool)
	{
		NSLog(@"No media pool\n");
		return;
	}
	
	// clear existing combo box items
	[comboBox removeAllItems];
	
	// append a combox box item for each clip
	for (unsigned long clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
	{
		NSString* clipName = NULL;
		IBMDSwitcherClip* clip = mClips[clipIndex];
		
		// if the clip is invalid, the clip name will be blank
		result = clip->GetName((CFStringRef*)&clipName);
		if (FAILED(result))
		{
			NSLog(@"Could not get clip name\n");
			return;
		}
		
		// add the clip item
		NSString* itemText = [NSString stringWithFormat:@"Clip %lu: %@", clipIndex + 1, clipName];
		[comboBox addItemWithTitle:itemText];
		
		[clipName release];
	}
	
	// check we have stills
	if (! mStills)
	{
		NSLog(@"No stills\n");
		return;
	}
	
	// get the number of stills
	result = mStills->GetCount(&stillCount);
	if (FAILED(result))
	{
		NSLog(@"Could not get still count\n");
		return;
	}
	
	// append a combo box item for each still
	for (unsigned long stillIndex = 0; stillIndex < stillCount; ++stillIndex)
	{
		NSString* stillName = NULL;
		
		// if the still is invalid, the still name will be blank
		result = mStills->GetName(stillIndex, (CFStringRef*)&stillName);
		if (FAILED(result))
		{
			NSLog(@"Could not get still name\n");
			return;
		}
		
		// add the still item
		NSString* itemText = [NSString stringWithFormat:@"Still %lu: %@", stillIndex + 1, stillName];
		[comboBox addItemWithTitle:itemText];
		
		[stillName release];
	}
	
	// restore previously selected index
	[comboBox selectItemAtIndex:comboIndex];
}

- (void)updateMediaPlayerPopupSelection;
{
	// This method sets the media player combo box selected
	// item to the source of the media player and sets the
	// media player buttons enabled if the selected item is a clip.
	
	HRESULT result;
	BMDSwitcherMediaPlayerSourceType sourceType;
	uint32_t sourceIndex;
	bool valid = false;
	
	// check we have the media pool
	if (! mMediaPool)
	{
		NSLog(@"No media pool\n");
		return;
	}
	
	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		NSLog(@"No media player 1\n");
		return;
	}
	
	// get the source
	result = mMediaPlayers[0]->GetSource(&sourceType, &sourceIndex);
	if (FAILED(result))
	{
		NSLog(@"Could not get media player source\n");
		return;
	}
	
	// set the combo to the media player source
	if (sourceType == bmdSwitcherMediaPlayerSourceTypeClip)
	{
		int popupIndex = sourceIndex; // clip items are listed first in the combo box
		
		// check the clip index is valid
		if (sourceIndex >= (int)mClips.size())
		{
			NSLog(@"Invalid clip selection\n");
			return;
		}
		
		// only enable media player buttons if the clip is valid
		result = mClips[sourceIndex]->IsValid(&valid);
		if (FAILED(result))
		{
			NSLog(@"Could not get clip validity\n");
			return;
		}
		
		[mMediaPlayerSourcePopup selectItemAtIndex:popupIndex];
	}
	else if (sourceType == bmdSwitcherMediaPlayerSourceTypeStill)
	{
		uint32_t popupIndex = mClips.size() + sourceIndex; // still items are listed second in the combo box
		uint32_t stillCount;
		
		// get the number of stills
		result = mStills->GetCount(&stillCount);
		if (FAILED(result))
		{
			NSLog(@"Could not get still count\n");
			return;
		}
		
		// check the still index is valid
		if (sourceIndex >= stillCount)
		{
			NSLog(@"Invalid still selection\n");
			return;
		}
		
		[mMediaPlayerSourcePopup selectItemAtIndex: popupIndex];
	}
	else
	{
		NSLog(@"Unknown media player source type\n");
		return;
	}
	
	[self enableMediaPlayerButtons:valid];
}

- (void)enableMediaPlayerButtons:(bool)enabled
{
	// sets the media player button widgets enabled state
	
	[mMediaPlayerBeginButton setEnabled:enabled];
	[mMediaPlayerPreviousButton setEnabled:enabled];
	[mMediaPlayerPlayButton setEnabled:enabled];
	[mMediaPlayerNextButton setEnabled:enabled];
	[mMediaPlayerLoopButton setEnabled:enabled];}

- (void)updateMediaPoolPopupSelection;
{
	// This method sets the media pool combo box
	// selected item if it is not already set
	
	int comboIndex = [mMediaPoolTargetPopup indexOfSelectedItem];
	if (comboIndex < 0)
		[mMediaPoolTargetPopup selectItemAtIndex: 0];
}

- (void)enableMediaPoolWidgets:(bool)enabled
{
	// sets the media pool widgets enabled state
	[mMediaPoolTargetPopup setEnabled:enabled];
	[mMediaPoolUploadButton setEnabled:enabled];
}

@end
