/* -LICENSE-START-
** Copyright (c) 2012 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include <cstdio>
#include <new>
#include "MediaPoolTransfer.h"
#include "TGALoader.h"
#include "CallbackMonitors.h"

// ----------------------------------------------------------

MediaPoolTransfer::MediaPoolTransfer(NSWindow* window, IBMDSwitcher* switcher, IBMDSwitcherMediaPool* mediaPool)
 :	mWindow(window),
	mSwitcher(switcher),
	mMediaPool(mediaPool)
{
	mSwitcher->AddRef();
	mMediaPool->AddRef();
}

MediaPoolTransfer::~MediaPoolTransfer()
{
	mSwitcher->Release();
	mMediaPool->Release();
}

IBMDSwitcherFrame* MediaPoolTransfer::loadFrame(std::string path)
{
	HRESULT result;
	// frame
	IBMDSwitcherFrame* frame = NULL;
	unsigned int frameDataSize;
	void* frameData = NULL;
	unsigned char* frameDataIter = NULL;
	int frameBytesPerPixel;
	BMDSwitcherPixelFormat framePixelFormat;
	// TGA image
	unsigned char* imageDataIter = NULL;
	int imageBytesPerPixel;
	// switcher
	BMDSwitcherVideoMode videoMode;
	int width, height;	// the TGA image and frame must match the switcher resolution

	// attempt to load and parse the TGA file
	TGALoader tgaLoader(path);

	// check the tga was successfully loaded and parsed
	if (! tgaLoader.valid())
	{
		NSLog(@"Could not load and/or parse tga file\n");
		result = E_FAIL;
		goto finish;
	}

	// we don't support images with right to left alignment
	if (tgaLoader.imageDescriptorFlags() & kTGAImageDescriptor_RightToLeft)
	{
		NSLog(@"TGA images with right to left alignment are not supported\n");
		goto finish;
	}

	// get the current video mode
	result = mSwitcher->GetVideoMode(&videoMode);
	if (FAILED(result))
	{
		NSLog(@"Could not get switcher video mode\n");
		goto finish;
	}

	// create the frame with the dimensions of the current video mode
	switch (videoMode)
	{
		case bmdSwitcherVideoMode625i50PAL:
		case bmdSwitcherVideoMode625i50Anamorphic:
			width = 720;
			height = 576;
			break;
		case bmdSwitcherVideoMode525i5994NTSC:
		case bmdSwitcherVideoMode525i5994Anamorphic:
			width = 720;
			height = 486;
			break;
		case bmdSwitcherVideoMode720p50:
		case bmdSwitcherVideoMode720p5994:
			width = 1280;
			height = 720;
			break;
		case bmdSwitcherVideoMode1080i50:
		case bmdSwitcherVideoMode1080i5994:
		case bmdSwitcherVideoMode1080p2398:
		case bmdSwitcherVideoMode1080p24:
		case bmdSwitcherVideoMode1080p25:
		case bmdSwitcherVideoMode1080p2997:
		case bmdSwitcherVideoMode1080p50:
		case bmdSwitcherVideoMode1080p5994:
			width = 1920;
			height = 1080;
			break;
		case bmdSwitcherVideoMode4KHDp2398:
		case bmdSwitcherVideoMode4KHDp24:
		case bmdSwitcherVideoMode4KHDp25:
		case bmdSwitcherVideoMode4KHDp2997:
		case bmdSwitcherVideoMode4KHDp50:
		case bmdSwitcherVideoMode4KHDp5994:
			width = 3840;
			height = 2160;
			break;
		default:
			NSLog(@"Could not determine frame resolution\n");
			result = E_FAIL;
			goto finish;
	};

	// check the image matches the video mode resolution
	if ((width != tgaLoader.width()) || (height != tgaLoader.height()))
	{
		NSLog(@"TGA file does not match switcher video mode\n");
		result = E_FAIL;
		goto finish;
	}

	// determine image bytes per pixel and frame pixel format
	switch (tgaLoader.bitsPerPixel())
	{
		case 32:
			framePixelFormat = bmdSwitcherPixelFormat8BitARGB;
			imageBytesPerPixel = 4;
			frameBytesPerPixel = 4;
			break;
		case 24:
			framePixelFormat = bmdSwitcherPixelFormat8BitXRGB;
			imageBytesPerPixel = 3;
			frameBytesPerPixel = 4;
			break;
		default:
			NSLog(@"Could not determine pixel format\n");
			result = E_FAIL;
			goto finish;
	}

	// create the frame
	result = mMediaPool->CreateFrame(framePixelFormat, width, height, &frame);
	if (FAILED(result))
	{
		NSLog(@"Could not create frame\n");
		goto finish;
	}

	// get the frame size
	frameDataSize = frame->GetRowBytes() * frame->GetHeight();

	// get the frame data
	result = frame->GetBytes(&frameData);
	if (FAILED(result))
	{
		NSLog(@"Could not get frame data\n");
		goto finish;
	}

	// sanity check bytes per pixel for frame and TGA image so we can make assumptions during loading
	if ((frameBytesPerPixel != 4) || (imageBytesPerPixel < 3))
	{
		NSLog(@"Unexpected frame and/or image bytes per pixel\n");
		result = E_FAIL;
		goto finish;
	}

	// load the frame data
	// frame data alignment is top to bottom and left to right
	frameDataIter = (unsigned char*)frameData;
	imageDataIter = (unsigned char*)tgaLoader.imageData();
	for (int y = 0; y < height; y++)
	{
		if ((tgaLoader.imageDescriptorFlags() & kTGAImageDescriptor_TopToBottom) == 0)
		{
			// tga image has bottom to top alignment
			imageDataIter = (unsigned char*)tgaLoader.imageData() + ((height - y - 1) * width * imageBytesPerPixel);
		}

		for (int x = 0; x < width; x++)
		{
			// ensure we do not access data outside of the valid range
			if (((frameDataIter - (unsigned char*)frameData) >= (int)(frameDataSize + frameBytesPerPixel)) ||
				((imageDataIter - (unsigned char*)tgaLoader.imageData()) >= (int)(tgaLoader.imageDataSize() + imageBytesPerPixel)))
			{
				NSLog(@"A data bounds error has been detected during loading\n");
				result = E_FAIL;
				goto finish;
			}

			// we know we have at least 3 bytes per pixel for both the frame and TGA image
			*frameDataIter++ = *imageDataIter++;
			*frameDataIter++ = *imageDataIter++;
			*frameDataIter++ = *imageDataIter++;

			// the frame is always 4 bytes per pixel but the tga image may be 3 or 4 bytes per pixel
			if (imageBytesPerPixel == 4)
				*frameDataIter++ = *imageDataIter++;
			else
				*frameDataIter++ = 0;
		}
	}

	result = S_OK;

finish:
	if (FAILED(result))
	{
		// the load failed
		if (frame)
		{
			// free the invalid frame
			frame->Release();
			frame = NULL;
		}
	}

	return frame;
}

std::string MediaPoolTransfer::fileNameFromFilePath(const std::string& filePath)
{
	NSString* filePathNS = [NSString stringWithCString:filePath.c_str() encoding:[NSString defaultCStringEncoding]];
	NSString* fileNameNS = [[filePathNS lastPathComponent] stringByDeletingPathExtension];
	std::string fileName([fileNameNS cStringUsingEncoding: NSASCIIStringEncoding]);
	
	return fileName;
}

// ----------------------------------------------------------

StillTransfer::StillTransfer(SwitcherMediaPoolAppDelegate* uiDelegate, NSWindow* window, IBMDSwitcher* switcher, IBMDSwitcherMediaPool* mediaPool, IBMDSwitcherStills* stills)
 :	MediaPoolTransfer(window, switcher, mediaPool),
	mStills(stills),
	mTransferActive(false),
	mTransferStillIndex(-1),
	mTransferFrame(NULL)
{
	mStills->AddRef();
	mLockCallback = new LockCallback(uiDelegate);
}

StillTransfer::~StillTransfer()
{
	mLockCallback->Release();
	mStills->Release();
	if (mTransferFrame)
		mTransferFrame->Release();
}

bool StillTransfer::upload(int stillIndex, std::string filePath)
{
	// This method prepares the frame for upload before requesting
	// a lock. We do this because we don't want to prevent other
	// clients from obtaining lock while we are preparing the frame.
	// If we were performing a more lengthy operation such as
	// decompressing, resizing and/or converting the frame then this
	// becomes more important. There is also the possibility that the
	// frame preparation will fail, in which case we don't need the lock.

	HRESULT result;
	IBMDSwitcherFrame* frame = NULL;

	// one still transfer at a time
	if (mTransferActive)
	{
		NSLog(@"Can not transfer more than one still at a time\n");
		goto error;
	}

	// load the frame
	frame = loadFrame(filePath);
	if (! frame)
	{
		NSLog(@"Could not load frame from file\n");
		result = E_FAIL;
		goto error;
	}

	// set transfer properties
	mTransferActive = true;
	mTransferStillIndex = stillIndex;
	mTransferName = fileNameFromFilePath(filePath);
	if (mTransferFrame)
		mTransferFrame->Release();
	mTransferFrame = frame;

	// request a stills lock, the transfer will begin when
	// we are notified that the lock has been obtained
	result = mStills->Lock(mLockCallback);
	if (FAILED(result))
	{
		NSLog(@"Could not request stills lock\n");
		goto error;
	}

	return true; // success

error:
	mTransferActive = false;
	if (frame)
		frame->Release();

	// show a message box
	NSAlert* alert = [[NSAlert alloc] init];
	[alert setMessageText:@"Error"];
	[alert setInformativeText:@"Still transfer failed"];
	[alert addButtonWithTitle:@"OK"];
	[alert beginSheetModalForWindow:mWindow completionHandler:nullptr];

	return false; // failed
}

void StillTransfer::onLockObtained()
{
	// now that we have the lock we can proceed to upload
	HRESULT result;
	NSString* fileName = NULL;

	// check we have an active transfer
	if (! mTransferActive)
	{
		NSLog(@"Lock obtained without an active transfer\n");
		result = E_FAIL;
		goto finish;
	}

	// check we have a frame
	if (! mTransferFrame)
	{
		NSLog(@"Lock obtained without a valid frame\n");
		result = E_FAIL;
		goto finish;
	}

	// Unlike clips, invalidating a still prior to uploading is not currently enforced by the SDK.
	// If we upload to a still location that is in use by a media player then the media player will display
	// the existing still until the upload completes and then it will swap to display the uploaded still.

	// upload
	fileName = [NSString stringWithCString:mTransferName.c_str() encoding:[NSString defaultCStringEncoding]];
	result = mStills->Upload(mTransferStillIndex, (CFStringRef)fileName, mTransferFrame);

	// release our reference to the frame
	mTransferFrame->Release();
	mTransferFrame = NULL;

finish:
	if (FAILED(result))
	{
		// an error has occured, so we end the transfer
		onTransferEnded(false);
	}
}

void StillTransfer::onTransferEnded(bool success)
{
	HRESULT result;

	// release the frame
	if (mTransferFrame)
	{
		mTransferFrame->Release();
		mTransferFrame = NULL;
	}

	// release the lock so that other clients can transfer stills
	result = mStills->Unlock(mLockCallback);
	if (FAILED(result))
	{
		NSLog(@"Could not unlock stills\n");
		goto finish;
	}

finish:
	// show a message box if transfer failed
	if (! success)
	{
		NSAlert* alert = [[NSAlert alloc] init];
		[alert setMessageText:@"Error"];
		[alert setInformativeText:@"Still transfer failed"];
		[alert addButtonWithTitle:@"OK"];
		[alert beginSheetModalForWindow:mWindow completionHandler:nullptr];
	}

	mTransferActive = false; // transfer has ended
}

// ----------------------------------------------------------

ClipTransfer::ClipTransfer(SwitcherMediaPoolAppDelegate* uiDelegate, NSWindow* window, IBMDSwitcher* switcher, IBMDSwitcherMediaPool* mediaPool, IBMDSwitcherClip* clip)
 :	MediaPoolTransfer(window, switcher, mediaPool),
	mClip(clip),
	mTransferActive(FALSE),
	mTransferFrame(NULL)
{
	mClip->AddRef();

	uint32_t clipIndex = 0xFFFFFFFF;
	HRESULT result = mClip->GetIndex(&clipIndex);
	if (FAILED(result))
		NSLog(@"Could not get clip index\n");

	mLockCallback = new LockCallback(uiDelegate, clipIndex);
}

ClipTransfer::~ClipTransfer()
{
	mLockCallback->Release();
	mClip->Release();
	if (mTransferFrame)
		mTransferFrame->Release();
}

bool ClipTransfer::upload(const std::list<std::string>& filePaths)
{
	// This method prepares the fist frame for upload before requesting
	// a lock. We do this because we don't want to prevent other
	// clients from obtaining lock while we are preparing the frame.
	// The next frame is prepared while the current frame transfers so that
	// we are not introducting delays between uploading frames.
	// We only ever prepare one frame in advance to avoid having the
	// entire clip in memory.

	HRESULT result;

	// one clip transfer at a time
	if (mTransferActive)
	{
		NSLog(@"Can not transfer more than one clip at a time\n");
		return false; // ignore the upload request
	}

	// must be at least one file path
	if (filePaths.size() < 1)
	{
		NSLog(@"No files to transfer\n");
		goto error;
	}

	// set transfer properties
	mTransferActive = true;
	mTransferFilePaths = filePaths;
	mTransferName = fileNameFromFilePath(filePaths.front()); // name the clip using the first file
	mTransferredFrameCount = 0;

	// prepare the frame before we request the lock
	if (! prepareNextFrame())
	{
		NSLog(@"Could not prepare first frame\n");
		goto error;
	}

	// request a clip lock, the transfer will begin when
	// we are notified that the lock has been obtained
	result = mClip->Lock(mLockCallback);
	if (FAILED(result))
	{
		NSLog(@"Could not request clip lock\n");
		goto error;
	}

	return true; // success

error:
	mTransferActive = false;
	if (mTransferFrame)
	{
		mTransferFrame->Release();
		mTransferFrame = NULL;
	}

	// show a message box
	NSAlert* alert = [[NSAlert alloc] init];
	[alert setMessageText:@"Error"];
	[alert setInformativeText:@"Clip transfer failed"];
	[alert addButtonWithTitle:@"OK"];
	[alert beginSheetModalForWindow:mWindow completionHandler:nullptr];

	return false; // failed
}

bool ClipTransfer::prepareNextFrame()
{
	// no more files to upload?
	if (mTransferFilePaths.size() == 0)
	{
		NSLog(@"No more files\n");
		return false;
	}

	// load the frame
	if (mTransferFrame)
		mTransferFrame->Release();
	mTransferFrame = loadFrame(mTransferFilePaths.front());
	mTransferFilePaths.pop_front();
	if (! mTransferFrame)
	{
		NSLog(@"Could not load frame from file\n");
		return false;
	}

	return true;
}

bool ClipTransfer::uploadNextFrame()
{
	HRESULT result;

	// check we have an active transfer
	if (! mTransferActive)
	{
		NSLog(@"No active transfer\n");
		result = E_FAIL;
		goto finish;
	}

	// check we have a preprepared frame to upload
	if (! mTransferFrame)
	{
		NSLog(@"No frame prepared\n");
		result = E_FAIL;
		goto finish;
	}

	// upload
	result = mClip->UploadFrame(mTransferredFrameCount, mTransferFrame);
	if (FAILED(result))
	{
		NSLog(@"Could not upload clip frame\n");
		result = E_FAIL;
		goto finish;
	}

	// release our reference to the frame
	mTransferFrame->Release();
	mTransferFrame = NULL;

	// if we have more frames, prepare the next frame
	if (mTransferFilePaths.size() && ! prepareNextFrame())
	{
		NSLog(@"Could not prepare next frame\n");

		// we now know that we can't upload the entire clip, so we
		// cancel the current frame upload and end the clip transfer
		result = mClip->CancelTransfer();
		if (FAILED(result))
			NSLog(@"Could not cancel transfer");

		result = E_FAIL;
		goto finish;
	}

	result = S_OK;

finish:
	return SUCCEEDED(result);
}

void ClipTransfer::onLockObtained()
{
	// now that we have the lock, we can proceed with invalidating and uploading the clip

	// we must invalidate the clip before uploading frames
	// this is enforced by the SDK because clips should not change while in use by media players
	HRESULT result = mClip->SetInvalid();
	if (FAILED(result))
	{
		NSLog(@"Could not invalidate clip\n");
		result = E_FAIL;
		goto finish;
	}

	// now we can upload the first frame, which was prepared earlier
	if (! uploadNextFrame())
	{
		result = E_FAIL;
		goto finish;
	}

finish:
	if (FAILED(result))
	{
		// an error has occured, so we end the transfer without success
		onTransferEnded(false);
	}
}

bool ClipTransfer::onTransferEnded(bool success)
{
	HRESULT result;
	NSString* fileName = NULL;
	
	// an individual frame transfer has ended
	if (! success)
		goto endClipTransfer;

	// we have successfully transferred a frame
	++mTransferredFrameCount;

	// upload the next frame
	if (mTransferFrame)
	{
		success = uploadNextFrame();
		if (! success)
			goto endClipTransfer;

		return false; // we are not finished yet
	}

	// we have uploaded all frames, set clip as valid
	fileName = [NSString stringWithCString:mTransferName.c_str() encoding:[NSString defaultCStringEncoding]];
	result = mClip->SetValid((CFStringRef)fileName, mTransferredFrameCount);
	if (FAILED(result))
	{
		NSLog(@"Could not set clip valid\n");
		success = false;
	}

endClipTransfer:
	// release the lock so that other clients can transfer clips
	result = mClip->Unlock(mLockCallback);
	if (FAILED(result))
	{
		NSLog(@"Could not unlock clip\n");
	}

	// release the frame
	if (mTransferFrame)
	{
		mTransferFrame->Release();
		mTransferFrame = NULL;
	}

	mTransferActive = false; // transfer has ended

	// show a message box if transfer failed
	if (! success)
	{
		NSAlert* alert = [[NSAlert alloc] init];
		[alert setMessageText:@"Error"];
		[alert setInformativeText:@"Clip transfer failed"];
		[alert addButtonWithTitle:@"OK"];
		[alert beginSheetModalForWindow:mWindow completionHandler:nullptr];
	}

	return true;
}
