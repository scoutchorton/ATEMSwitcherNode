/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "com_ptr.h"
#include "BMDSwitcherAPI.h"
#include <cstdio>
#include <map>
#include <string>
#include <utility>
#include <vector>

static const std::map<BMDSwitcherConnectToFailure, std::string> kConnectFailReasonCodes =
{
	{ bmdSwitcherConnectToFailureNoResponse,			"No response" },
	{ bmdSwitcherConnectToFailureIncompatibleFirmware,	"Incompatible firmware" },
	{ bmdSwitcherConnectToFailureCorruptData,			"Corrupt data" },
	{ bmdSwitcherConnectToFailureStateSync,				"State synchronisation failed" },
	{ bmdSwitcherConnectToFailureStateSyncTimedOut,		"State synchronisation timed-out" },
};

static const std::map<BMDSwitcherVideoMode, std::string> kSwitcherVideoModes =
{
	{ bmdSwitcherVideoMode525i5994NTSC,			"525i59.94 NTSC"},
	{ bmdSwitcherVideoMode625i50PAL,			"625i50 PAL"},
	{ bmdSwitcherVideoMode525i5994Anamorphic,	"525i59.94 Anamorphic"},
	{ bmdSwitcherVideoMode625i50Anamorphic,		"625i50 Anamorphic"},
	{ bmdSwitcherVideoMode720p50,				"HD 720p50"},
	{ bmdSwitcherVideoMode720p5994,				"HD 720p59.94"},
	{ bmdSwitcherVideoMode1080i50,				"HD 1080i50"},
	{ bmdSwitcherVideoMode1080i5994,			"HD 1080i59.94"},
	{ bmdSwitcherVideoMode1080p2398,			"HD 1080p23.98"},
	{ bmdSwitcherVideoMode1080p24,				"HD 1080p24"},
	{ bmdSwitcherVideoMode1080p25,				"HD 1080p25"},
	{ bmdSwitcherVideoMode1080p2997,			"HD 1080p29.97"},
	{ bmdSwitcherVideoMode1080p50,				"HD 1080p50"},
	{ bmdSwitcherVideoMode1080p5994,			"HD 1080p59.94"},
	{ bmdSwitcherVideoMode4KHDp2398,			"UHD 2160p23.98"},
	{ bmdSwitcherVideoMode4KHDp24,				"UHD 2160p24"},
	{ bmdSwitcherVideoMode4KHDp25,				"UHD 2160p25"},
	{ bmdSwitcherVideoMode4KHDp2997,			"UHD 2160p29.97"},
	{ bmdSwitcherVideoMode4KHDp50,				"UHD 2160p50"},
	{ bmdSwitcherVideoMode4KHDp5994,			"UHD 2160p59.94"},
	{ bmdSwitcherVideoMode8KHDp2398,			"UHD 4320p23.98"},
	{ bmdSwitcherVideoMode8KHDp24,				"UHD 4320p24"},
	{ bmdSwitcherVideoMode8KHDp25,				"UHD 4320p25"},
	{ bmdSwitcherVideoMode8KHDp2997,			"UHD 4320p29.97"},
	{ bmdSwitcherVideoMode8KHDp50,				"UHD 4320p50"},
	{ bmdSwitcherVideoMode8KHDp5994,			"UHD 4320p59.94"},
};

static const std::map<BMDSwitcherPortType, std::string> kSwitcherPortTypes =
{
	{ bmdSwitcherPortTypeExternal,				"External" },
	{ bmdSwitcherPortTypeBlack,					"Black Video" },
	{ bmdSwitcherPortTypeColorBars,				"Color-Bars" },
	{ bmdSwitcherPortTypeColorGenerator,		"Color Generator" },
	{ bmdSwitcherPortTypeMediaPlayerFill,		"Media-Player Fill" },
	{ bmdSwitcherPortTypeMediaPlayerCut,		"Media-Player Cut" },
	{ bmdSwitcherPortTypeSuperSource,			"Super-Source" },
	{ bmdSwitcherPortTypeMixEffectBlockOutput,	"Mix-Effect Block Output" },
	{ bmdSwitcherPortTypeAuxOutput,				"Auxiliary Output" },
	{ bmdSwitcherPortTypeKeyCutOutput,			"Key Cut Output" },
};

static const std::vector<std::pair<const REFIID, std::string>> kSwitcherTransitionStyles =
{
	std::make_pair(IID_IBMDSwitcherTransitionMixParameters,		"Mix"),
	std::make_pair(IID_IBMDSwitcherTransitionDipParameters,		"Dip"),
	std::make_pair(IID_IBMDSwitcherTransitionWipeParameters,	"Wipe"),
	std::make_pair(IID_IBMDSwitcherTransitionDVEParameters,		"DVE"),
	std::make_pair(IID_IBMDSwitcherTransitionStingerParameters,	"Stinger"),
};

static const std::map<BMDSwitcherExternalPortType, std::string> kSwitcherExternalPortTypes =
{
	{ bmdSwitcherExternalPortTypeSDI,			"SDI" },
	{ bmdSwitcherExternalPortTypeHDMI,			"HDMI" },
	{ bmdSwitcherExternalPortTypeComponent,		"Component" },
	{ bmdSwitcherExternalPortTypeComposite,		"Composite" },
	{ bmdSwitcherExternalPortTypeSVideo,		"S-Video" },
	{ bmdSwitcherExternalPortTypeXLR,			"XLR Audio" },
	{ bmdSwitcherExternalPortTypeAESEBU,		"AES EBU Audio" },
	{ bmdSwitcherExternalPortTypeRCA,			"RCA Audio" },
	{ bmdSwitcherExternalPortTypeInternal,		"Internal" },
	{ bmdSwitcherExternalPortTypeTSJack,		"TS Jack" },
	{ bmdSwitcherExternalPortTypeMADI,			"MADI" },
	{ bmdSwitcherExternalPortTypeTRS,			"TRS" },
};

static const std::map<BMDSwitcherAudioInputType, std::string> kSwitcherAudioInputTypes =
{
	{ bmdSwitcherAudioInputTypeEmbeddedWithVideo,	"Embedded with Video" },
	{ bmdSwitcherAudioInputTypeMediaPlayer,			"Media Player" },
	{ bmdSwitcherAudioInputTypeAudioIn,				"Audio input" },
};

static const std::map<BMDSwitcherFairlightAudioInputType, std::string> kSwitcherFairlightAudioInputTypes =
{
	{ bmdSwitcherFairlightAudioInputTypeEmbeddedWithVideo,	"Embedded with Video" },
	{ bmdSwitcherFairlightAudioInputTypeMediaPlayer,		"Media Player" },
	{ bmdSwitcherFairlightAudioInputTypeAudioIn,			"Audio input" },
	{ bmdSwitcherFairlightAudioInputTypeMADI,				"MADI input" },
};

static const std::vector<BMDSwitcherInputAvailability> kSwitcherInputAvailabilty =
{
	bmdSwitcherInputAvailabilityMixEffectBlock0,
	bmdSwitcherInputAvailabilityMixEffectBlock1,
	bmdSwitcherInputAvailabilityMixEffectBlock2,
	bmdSwitcherInputAvailabilityMixEffectBlock3,
	bmdSwitcherInputAvailabilityAuxOutputs,
	bmdSwitcherInputAvailabilityMultiView,
	bmdSwitcherInputAvailabilitySuperSourceArt,
	bmdSwitcherInputAvailabilitySuperSourceBox,
	bmdSwitcherInputAvailabilityInputCut,
};

void						get_switcher_inputs(com_ptr<IBMDSwitcher>& switcher, std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs);
void						get_switcher_mix_effect_blocks(com_ptr<IBMDSwitcher>& switcher, std::vector<com_ptr<IBMDSwitcherMixEffectBlock>>& mixEffectBlocks);

std::string					get_product_name(com_ptr<IBMDSwitcher>& switcher);
int							get_usk_count_for_meb(com_ptr<IBMDSwitcherMixEffectBlock>& mixEffectBlock);
std::vector<std::string>	get_transition_styles_for_meb(com_ptr<IBMDSwitcherMixEffectBlock>& mixEffectBlock);
int							get_downstream_keyer_count(com_ptr<IBMDSwitcher>& switcher);
int							get_input_type_count(std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs, BMDSwitcherPortType portType);
int							get_media_pool_clip_count(com_ptr<IBMDSwitcherMediaPool>& mediaPool);
int							get_media_pool_stills_count(com_ptr<IBMDSwitcherStills>& stills);

bool						does_support_advanced_chroma_keyers(std::vector<com_ptr<IBMDSwitcherMixEffectBlock>>& mixEffectBlocks);

void						print_supported_video_modes(com_ptr<IBMDSwitcher>& switcher);
void						print_switcher_inputs(std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs);
void						print_input_availability_matrix(std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs, int mixEffectCount);
void						print_fairlight_audio_inputs(com_ptr<IBMDSwitcherFairlightAudioMixer>& fairlightAudioMixer, std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs);
void						print_audio_inputs(com_ptr<IBMDSwitcherAudioMixer>& audioMixer, std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs);
void						print_media_pool_stills(com_ptr<IBMDSwitcherStills>& stills);
void						print_media_pool_clips(com_ptr<IBMDSwitcherMediaPool>& mediaPool);


std::string CFStringToStdString(CFStringRef str)
{
	CFIndex stringSize = CFStringGetLength(str) + 1;
	char buffer[stringSize];
	CFStringEncoding encoding = CFStringGetSystemEncoding();
	const char *ptr = CFStringGetCStringPtr(str, encoding);
	if (ptr == NULL)
	{
		if (CFStringGetCString(str, buffer, stringSize, encoding))
			ptr = buffer;
	}
	return ptr;
}


template<typename T>
std::string LookupString(const std::map<T, std::string>& stringMap, T index)
{
	std::string connectFailReasonStr;
	auto iter = stringMap.find(index);

	if (iter != stringMap.end())
		return iter->second;
	else
		return "Unknown";
}

int main (int argc, char** argv)
{
	com_ptr<IBMDSwitcherDiscovery>						switcherDiscovery;
	com_ptr<IBMDSwitcher>								switcher;
	std::vector<com_ptr<IBMDSwitcherInput>>				switcherInputs;
	std::vector<com_ptr<IBMDSwitcherMixEffectBlock>>	switcherMixEffectBlocks;
	com_ptr<IBMDSwitcherMediaPool>						switcherMediaPool;
	com_ptr<IBMDSwitcherStills>							switcherStills;
	com_ptr<IBMDSwitcherFairlightAudioMixer>			fairlightAudioMixer;
	std::string											productName;

	BMDSwitcherConnectToFailure							connectToFailReason;
	HRESULT												result;

	if (argc != 2)
	{
		fprintf(stderr, "Expected: %s <ip_address>\n", argv[0]);
		return 1;
	}

	switcherDiscovery = CreateBMDSwitcherDiscoveryInstance();
	if (!switcherDiscovery)
	{
		fprintf(stderr, "A Switcher Discovery instance could not be created.  The Switcher drivers may not be installed.\n");
		return 1;
	}
	
	// Connect to switcher with address provided by argv
	CFStringRef addressString = CFStringCreateWithCString(kCFAllocatorDefault, argv[1], kCFStringEncodingUTF8);
	result = switcherDiscovery->ConnectTo(addressString, switcher.releaseAndGetAddressOf(), &connectToFailReason);
	if (result != S_OK)
	{
		std::string connectFailReasonStr = LookupString<BMDSwitcherConnectToFailure>(kConnectFailReasonCodes, connectToFailReason);
		fprintf(stderr, "Failed to connect to switcher at address %s, reason = %s\n", argv[1], connectFailReasonStr.c_str());
		return 1;
	}
	CFRelease(addressString);
	
	// Print switcher product name
	printf("Switcher found at %s\n", argv[1]);
	productName = get_product_name(switcher);
	printf(" %-40s %s\n", "Product Name:", productName.c_str());
	
	// Print current and MultiView video modes
	BMDSwitcherVideoMode currentVideoMode;
	if (switcher->GetVideoMode(&currentVideoMode) == S_OK)
	{
		std::string currentVideoModeStr = LookupString<BMDSwitcherVideoMode>(kSwitcherVideoModes, currentVideoMode);
		printf(" %-40s %s\n", "Current Video Mode:", currentVideoModeStr.c_str());

		BMDSwitcherVideoMode multiViewVideoMode;
		if (switcher->GetMultiViewVideoMode(currentVideoMode, &multiViewVideoMode) == S_OK)
		{
			std::string multiViewVideoModeStr = LookupString<BMDSwitcherVideoMode>(kSwitcherVideoModes, multiViewVideoMode);
			printf(" %-40s %s\n", "MultiView Video Mode:", multiViewVideoModeStr.c_str());
		}
	}
	
	// Print the power status of switcher
	BMDSwitcherPowerStatus powerStatus;
	if (switcher->GetPowerStatus(&powerStatus) == S_OK)
	{
		printf(" %-40s %s\n", "Power Supply 1:", powerStatus & bmdSwitcherPowerStatusSupply1 ? "Powered" : "Not powered");
		printf(" %-40s %s\n", "Power Supply 2:", powerStatus & bmdSwitcherPowerStatusSupply2 ? "Powered" : "Not powered");
	}

	// Print whether Fairlight or original audio mixer
	fairlightAudioMixer = com_ptr<IBMDSwitcherFairlightAudioMixer>(IID_IBMDSwitcherFairlightAudioMixer, switcher);
	printf(" %-40s %s\n", "Audio Mixer:", fairlightAudioMixer ? "Fairlight" : "Original");

	// Print Mix Effect block count
	get_switcher_mix_effect_blocks(switcher, switcherMixEffectBlocks);
	printf(" %-40s %d\n", "Number of Mix Effect Blocks:", (int)switcherMixEffectBlocks.size());

	for (unsigned int i = 0; i < switcherMixEffectBlocks.size(); i++)
	{
		printf(" - Number of Upstream Keyers for ME%d:     %d\n", i, get_usk_count_for_meb(switcherMixEffectBlocks[i]));
		printf(" - Transition Styles supported by ME%d:    ", i);
		for (auto& transitionStyleStr : get_transition_styles_for_meb(switcherMixEffectBlocks[i]))
			printf("%s ", transitionStyleStr.c_str());
		printf("\n");
	}

	printf(" %-40s %s\n", "Supports Advanced Chroma Keyers:", does_support_advanced_chroma_keyers(switcherMixEffectBlocks) ? "Yes" : "No");
	printf(" %-40s %d\n", "Number of Downstream Keyers", get_downstream_keyer_count(switcher));

	// Print swicther input type counts
	get_switcher_inputs(switcher, switcherInputs);
	printf(" %-40s %d\n", "Number of External Inputs:", get_input_type_count(switcherInputs, bmdSwitcherPortTypeExternal));
	printf(" %-40s %d\n", "Number of SuperSources:", get_input_type_count(switcherInputs, bmdSwitcherPortTypeSuperSource));
	printf(" %-40s %d\n", "Number of Media Players:", get_input_type_count(switcherInputs, bmdSwitcherPortTypeMediaPlayerFill));
	printf(" %-40s %d\n", "Number of AUX Outputs:", get_input_type_count(switcherInputs, bmdSwitcherPortTypeAuxOutput));
	
	// Get Switcher Media pool.
	switcherMediaPool = com_ptr<IBMDSwitcherMediaPool>(IID_IBMDSwitcherMediaPool, switcher);
	if (switcherMediaPool)
	{
		// Get Switcher stills interfaceobject
		if (switcherMediaPool->GetStills(switcherStills.releaseAndGetAddressOf()) == S_OK)
		{
			printf(" %-40s %u\n", "Number of Stills in Media Pool:", get_media_pool_stills_count(switcherStills));
		}
		
		printf(" %-40s %u\n", "Number of Clips in Media Pool:", get_media_pool_clip_count(switcherMediaPool));
	}
	
	print_supported_video_modes(switcher);
	print_switcher_inputs(switcherInputs);
	print_input_availability_matrix(switcherInputs, (int)switcherMixEffectBlocks.size());
	if (fairlightAudioMixer)
	{
		// Print Fairlight audiomixer inputs
		print_fairlight_audio_inputs(fairlightAudioMixer, switcherInputs);
	}
	else
	{
		// Print original audio mixer inputs
		com_ptr<IBMDSwitcherAudioMixer> audioMixer(IID_IBMDSwitcherAudioMixer, switcher);
		if (audioMixer)
			print_audio_inputs(audioMixer, switcherInputs);
	}
	
	if (switcherStills)
	{
		print_media_pool_stills(switcherStills);
	}
	
	if (switcherMediaPool)
	{
		print_media_pool_clips(switcherMediaPool);
	}

	return 0;
}

void get_switcher_inputs(com_ptr<IBMDSwitcher>& switcher, std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs)
{
	com_ptr<IBMDSwitcherInputIterator> inputIterator;
	if (switcher->CreateIterator(IID_IBMDSwitcherInputIterator, (void**)inputIterator.releaseAndGetAddressOf()) == S_OK)
	{
		com_ptr<IBMDSwitcherInput> input;
		while (inputIterator->Next(input.releaseAndGetAddressOf()) == S_OK)
			switcherInputs.push_back(std::move(input));
	}
}

void get_switcher_mix_effect_blocks(com_ptr<IBMDSwitcher>& switcher, std::vector<com_ptr<IBMDSwitcherMixEffectBlock>>& mixEffectBlocks)
{
	com_ptr<IBMDSwitcherMixEffectBlockIterator> mixEffectBlockIterator;
	if (switcher->CreateIterator(IID_IBMDSwitcherMixEffectBlockIterator, (void**)mixEffectBlockIterator.releaseAndGetAddressOf()) == S_OK)
	{
		com_ptr<IBMDSwitcherMixEffectBlock> mixEffectBlock;
		while (mixEffectBlockIterator->Next(mixEffectBlock.releaseAndGetAddressOf()) == S_OK)
			mixEffectBlocks.push_back(std::move(mixEffectBlock));
	}
}

int get_downstream_keyer_count(com_ptr<IBMDSwitcher>& switcher)
{
	int downstreamKeyerCount = 0;
	com_ptr<IBMDSwitcherDownstreamKeyIterator> dskIterator;
	if (switcher->CreateIterator(IID_IBMDSwitcherDownstreamKeyIterator, (void**)dskIterator.releaseAndGetAddressOf()) == S_OK)
	{
		com_ptr<IBMDSwitcherDownstreamKey> dsk;
		while (dskIterator->Next(dsk.releaseAndGetAddressOf()) == S_OK)
			downstreamKeyerCount++;
	}
	
	return downstreamKeyerCount;
}

bool does_support_advanced_chroma_keyers(std::vector<com_ptr<IBMDSwitcherMixEffectBlock>>& mixEffectBlocks)
{
	for (auto& mixEffectBlock : mixEffectBlocks)
	{
		com_ptr<IBMDSwitcherKeyIterator>	keyIterator;
		com_ptr<IBMDSwitcherKey>			keyer;

		if (mixEffectBlock->CreateIterator(IID_IBMDSwitcherKeyIterator, (void**)keyIterator.releaseAndGetAddressOf()) != S_OK)
			continue;
		
		while (keyIterator->Next(keyer.releaseAndGetAddressOf()) == S_OK)
		{
			bool advancedChromaSupported = false;
			// Check whether advanced chroma keying is supported by switcher
			if ((keyer->DoesSupportAdvancedChroma(&advancedChromaSupported) == S_OK) && advancedChromaSupported)
				return true;
		}
	}

	return false;
}

std::string get_product_name(com_ptr<IBMDSwitcher>& switcher)
{
	CFStringRef productNameString;
	
	// *** Print the product name of the Switcher
	if (switcher->GetProductName(&productNameString) != S_OK)
	{
		return "N/A";
	}
	
	std::string productName("");
	CFIndex stringSize = CFStringGetLength(productNameString) + 1;
	char stringBuffer[stringSize];
	if (CFStringGetCString(productNameString, stringBuffer, stringSize, kCFStringEncodingUTF8))
		productName = stringBuffer;

	CFRelease(productNameString);
	return productName;
}

int get_usk_count_for_meb(com_ptr<IBMDSwitcherMixEffectBlock>& mixEffectBlock)
{
	int									upstreamKeyerCount = 0;
	com_ptr<IBMDSwitcherKeyIterator>	keyIterator;
	com_ptr<IBMDSwitcherKey>			keyer;

	if (mixEffectBlock->CreateIterator(IID_IBMDSwitcherKeyIterator, (void**)keyIterator.releaseAndGetAddressOf()) != S_OK)
		return 0;
	
	while (keyIterator->Next(keyer.releaseAndGetAddressOf()) == S_OK)
		upstreamKeyerCount++;
	
	return upstreamKeyerCount;
}

std::vector<std::string> get_transition_styles_for_meb(com_ptr<IBMDSwitcherMixEffectBlock>& mixEffectBlock)
{
	std::vector<std::string>	supportedStyles;
	
	for (auto& transitionStyle: kSwitcherTransitionStyles)
	{
		com_ptr<IUnknown> transitionParameters;
		
		if (mixEffectBlock->QueryInterface(transitionStyle.first, (void**)transitionParameters.releaseAndGetAddressOf()) == S_OK)
			supportedStyles.push_back(transitionStyle.second);
	}
	
	return supportedStyles;
}

int get_input_type_count(std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs, BMDSwitcherPortType portType)
{
	int portCount = 0;

	for (auto& input : switcherInputs)
	{
		BMDSwitcherPortType type;
		if ((input->GetPortType(&type) == S_OK) && (type == portType))
			portCount++;
	}
	
	return portCount;
}

int get_media_pool_clip_count(com_ptr<IBMDSwitcherMediaPool>& mediaPool)
{
	uint32_t	clipCount;
	int			validClipCount = 0;
	
	if (mediaPool->GetClipCount(&clipCount) != S_OK)
		return 0;
	
	for (unsigned int i = 0; i < clipCount; i++)
	{
		// Count only clips marked as valid
		com_ptr<IBMDSwitcherClip> clip;
		if (mediaPool->GetClip(i, clip.releaseAndGetAddressOf()) == S_OK)
		{
			bool isValid;
			if ((clip->IsValid(&isValid) == S_OK) && isValid)
				validClipCount++;
		}
	}

	return validClipCount;
}

int get_media_pool_stills_count(com_ptr<IBMDSwitcherStills>& stills)
{
	uint32_t	stillsCount;
	int			validStillsCount = 0;
	
	if (stills->GetCount(&stillsCount) != S_OK)
		return 0;
	
	for (unsigned int i = 0; i < stillsCount; i++)
	{
		// Count only stills marked as valid
		bool isValid;
		if ((stills->IsValid(i, &isValid) == S_OK) && isValid)
			validStillsCount++;
	}
	return validStillsCount;
}

void print_supported_video_modes(com_ptr<IBMDSwitcher>& switcher)
{
	printf("\nSwitcher Video Mode Support:\n");
	printf(" %-25s%-35s%s\n", "Video Mode", "HD Down Converted Video Mode", "MultiView Video Mode");
	
	for (auto& mode : kSwitcherVideoModes)
	{
		bool videoModeSupported;
		BMDSwitcherVideoMode hdDownConvertedVideoMode;
		BMDSwitcherVideoMode multiViewVideoMode;
		std::string hdDownConvertedVideoModeStr = "-----";
		std::string multiViewVideoModeStr = "-----";

		if ((switcher->DoesSupportVideoMode(mode.first, &videoModeSupported) != S_OK) || !videoModeSupported)
			continue;

		if (switcher->GetDownConvertedHDVideoMode(mode.first, &hdDownConvertedVideoMode) == S_OK)
			hdDownConvertedVideoModeStr = LookupString<BMDSwitcherVideoMode>(kSwitcherVideoModes, hdDownConvertedVideoMode);
			
		if (switcher->GetMultiViewVideoMode(mode.first, &multiViewVideoMode) == S_OK)
			multiViewVideoModeStr = LookupString<BMDSwitcherVideoMode>(kSwitcherVideoModes, multiViewVideoMode);
			
		printf(" %-25s%-35s%s\n", mode.second.c_str(), hdDownConvertedVideoModeStr.c_str(), multiViewVideoModeStr.c_str());
	}
}

void print_switcher_inputs(std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs)
{
	printf("\nSwitcher Inputs:\n");
	printf(" %-7s%-12s%-22s%s\n", "ID", "Short Name", "Long Name", "Type");
	for (auto& input : switcherInputs)
	{
		BMDSwitcherPortType portType;
		BMDSwitcherInputId inputId;
		CFStringRef longName[21];
		CFStringRef shortName[5];
		BMDSwitcherExternalPortType externalPortType;
		std::string portTypeStr;

		if (input->GetPortType(&portType) != S_OK)
			continue;
		
		if (input->GetInputId(&inputId) != S_OK)
			continue;
		
		if (input->GetShortName(shortName) != S_OK)
			continue;
		
		if (input->GetLongName(longName) != S_OK)
			continue;
		
		if ((portType == bmdSwitcherPortTypeExternal) && (input->GetCurrentExternalPortType(&externalPortType) != S_OK))
			continue;
		
		portTypeStr = LookupString<BMDSwitcherPortType>(kSwitcherPortTypes, portType);
		
		printf(" %-7lld%-12s%-22s%s",
			   inputId,
			   CFStringToStdString(*shortName).c_str(),
			   CFStringToStdString(*longName).c_str(),
			   portTypeStr.c_str());

		if (portType == bmdSwitcherPortTypeExternal)
			printf(" (%s)", LookupString<BMDSwitcherExternalPortType>(kSwitcherExternalPortTypes, externalPortType).c_str());

		printf("\n");
	}
}

void print_input_availability_matrix(std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs, int mixEffectCount)
{
	printf("\nSwitcher Input Availability Matrix:\n");
	printf(" %-7s", "Input");
	for (int i = 0; i < mixEffectCount; i++)
		printf( "ME%d  ", i);
	printf("AUX  MV   SSA  SSB  CUT\n");
	
	for (auto& input : switcherInputs)
	{
		BMDSwitcherInputAvailability	inputAvailability;
		CFStringRef						shortName[5];

		if (input->GetInputAvailability(&inputAvailability) != S_OK)
			continue;
		
		if (input->GetShortName(shortName) != S_OK)
			continue;
		
		printf(" %-7s", CFStringToStdString(*shortName).c_str());
			
		for (auto availability : kSwitcherInputAvailabilty)
		{
			if (((mixEffectCount < 2) && (availability == bmdSwitcherInputAvailabilityMixEffectBlock1)) ||
				((mixEffectCount < 3) && (availability == bmdSwitcherInputAvailabilityMixEffectBlock2)) ||
				((mixEffectCount < 4) && (availability == bmdSwitcherInputAvailabilityMixEffectBlock3)))
			{
				continue;
			}
			printf(" %s   ", (availability & inputAvailability) ? "*" : "-");
		}
		
		printf("\n");
	}
}

void print_fairlight_audio_inputs(com_ptr<IBMDSwitcherFairlightAudioMixer>& fairlightAudioMixer, std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs)
{
	BMDSwitcherInputId									mediaPlayerTargetId = 0;
	com_ptr<IBMDSwitcherFairlightAudioInputIterator>	fairlightAudioInputIterator;
	com_ptr<IBMDSwitcherFairlightAudioInput>			fairlightAudioInput;

	printf("\nFairlight Audio Mixer Inputs:\n");
	printf(" %-7s%s\n", "ID", "Type");
	
	if (fairlightAudioMixer->CreateIterator(IID_IBMDSwitcherFairlightAudioInputIterator, (void**)fairlightAudioInputIterator.releaseAndGetAddressOf()) != S_OK)
		return;
	
	while (fairlightAudioInputIterator->Next(fairlightAudioInput.releaseAndGetAddressOf()) == S_OK)
	{
		BMDSwitcherFairlightAudioInputType		inputType;
		BMDSwitcherAudioInputId					inputId;
		BMDSwitcherExternalPortType				externalPortType;
		std::string								inputTypeStr;
		std::string								externalPortTypeStr;

		if (fairlightAudioInput->GetType(&inputType) != S_OK)
			continue;
		
		if (fairlightAudioInput->GetId(&inputId) != S_OK)
			continue;
		
		if (fairlightAudioInput->GetCurrentExternalPortType(&externalPortType) != S_OK)
			continue;
		
		inputTypeStr = LookupString<BMDSwitcherFairlightAudioInputType>(kSwitcherFairlightAudioInputTypes, inputType);
		externalPortTypeStr = LookupString<BMDSwitcherExternalPortType>(kSwitcherExternalPortTypes, externalPortType);
		
		printf(" %-7lld%s (%s",
			   inputId,
			   inputTypeStr.c_str(),
			   externalPortTypeStr.c_str());
		if (inputType == bmdSwitcherFairlightAudioInputTypeEmbeddedWithVideo)
		{
				// Display the short name of the corresponding switcher input
			com_ptr<IBMDSwitcherInput> switcherInput(IID_IBMDSwitcherInput, fairlightAudioInput);
			if (switcherInput)
			{
				CFStringRef inputShortName[5];
				if (switcherInput->GetShortName(inputShortName) == S_OK)
					printf(" - %s", CFStringToStdString(*inputShortName).c_str());
			}
		}
		else if (inputType == bmdSwitcherFairlightAudioInputTypeMediaPlayer)
		{
			// Cycle through switcher inputs and match port type with Media Player Fill
			for (auto& switcherInput : switcherInputs)
			{
				BMDSwitcherPortType portType;
				BMDSwitcherInputId inputId;
				if ((switcherInput->GetPortType(&portType) == S_OK) &&
					(portType == bmdSwitcherPortTypeMediaPlayerFill) &&
					(switcherInput->GetInputId(&inputId) == S_OK) &&
					(inputId >= mediaPlayerTargetId))
				{
					CFStringRef inputShortName[5];
					if (switcherInput->GetShortName(inputShortName) == S_OK)
						printf(" - %s", CFStringToStdString(*inputShortName).c_str());
					mediaPlayerTargetId = inputId + 1;
					break;
				}
			}
		}
		
		printf(")\n");
	}
}

void print_audio_inputs(com_ptr<IBMDSwitcherAudioMixer>& audioMixer, std::vector<com_ptr<IBMDSwitcherInput>>& switcherInputs)
{
	BMDSwitcherInputId							mediaPlayerTargetId = 0;
	com_ptr<IBMDSwitcherAudioInputIterator>		audioInputIterator;
	com_ptr<IBMDSwitcherAudioInput>				audioInput;

	printf("\nAudio Mixer Inputs:\n");
	printf(" %-7s%s\n", "ID", "Type");

	if (audioMixer->CreateIterator(IID_IBMDSwitcherAudioInputIterator, (void**)audioInputIterator.releaseAndGetAddressOf()) != S_OK)
		return;
	
	while (audioInputIterator->Next(audioInput.releaseAndGetAddressOf()) == S_OK)
	{
		BMDSwitcherAudioInputType		inputType;
		BMDSwitcherAudioInputId			inputId;
		BMDSwitcherExternalPortType		externalPortType;
		std::string						inputTypeStr;
		std::string						externalPortTypeStr;
		
		if (audioInput->GetType(&inputType) != S_OK)
			continue;
	
		if (audioInput->GetAudioInputId(&inputId) != S_OK)
			continue;
	
		if (audioInput->GetCurrentExternalPortType(&externalPortType) != S_OK)
			continue;
		
		inputTypeStr = LookupString<BMDSwitcherAudioInputType>(kSwitcherAudioInputTypes, inputType);
		externalPortTypeStr = LookupString<BMDSwitcherExternalPortType>(kSwitcherExternalPortTypes, externalPortType);
		
		printf(" %-7lld%s (%s",
			   inputId,
			   inputTypeStr.c_str(),
			   externalPortTypeStr.c_str());
		if (inputType == bmdSwitcherAudioInputTypeEmbeddedWithVideo)
		{
			// Display the short name of the corresponding switcher input
			com_ptr<IBMDSwitcherInput> switcherInput(IID_IBMDSwitcherInput, audioInput);
			if (switcherInput)
			{
				CFStringRef inputShortName[5];
				if (switcherInput->GetShortName(inputShortName) == S_OK)
					printf(" - %s", CFStringToStdString(*inputShortName).c_str());
			}
		}
		else if (inputType == bmdSwitcherAudioInputTypeMediaPlayer)
		{
			// Cycle through switcher inputs and match port type with Media Player Fill
			for (auto& switcherInput : switcherInputs)
			{
				BMDSwitcherPortType portType;
				BMDSwitcherInputId inputId;
				if ((switcherInput->GetPortType(&portType) == S_OK) &&
					(portType == bmdSwitcherPortTypeMediaPlayerFill) &&
					(switcherInput->GetInputId(&inputId) == S_OK) &&
					(inputId >= mediaPlayerTargetId))
				{
					CFStringRef inputShortName[5];
					if (switcherInput->GetShortName(inputShortName) == S_OK)
						printf(" - %s", CFStringToStdString(*inputShortName).c_str());
					mediaPlayerTargetId = inputId + 1;
					break;
				}
			}
		}
		
		printf(")\n");
	}
}

void print_media_pool_stills(com_ptr<IBMDSwitcherStills>& stills)
{
	uint32_t stillsCount;
	printf("\nMedia Pool Stills:\n");
	printf(" %-7s%s\n", "ID", "Name");
	
	if (stills->GetCount(&stillsCount) != S_OK)
		return;
		
	for (unsigned int i = 0; i < stillsCount; i++)
	{
		bool isValid;
		if ((stills->IsValid(i, &isValid) == S_OK) && isValid)
		{
			CFStringRef stillName;
			if (stills->GetName(i, &stillName) == S_OK)
				printf(" %-7d%s\n", i, CFStringToStdString(stillName).c_str());
		}
	}
	printf("\n");
}

void print_media_pool_clips(com_ptr<IBMDSwitcherMediaPool>& mediaPool)
{
	uint32_t clipCount;
	printf("\nMedia Pool Clips:\n");
	printf(" %-7s%-40s%s\n", "ID", "Name", "Frame Count");
	
	if (mediaPool->GetClipCount(&clipCount) != S_OK)
		return;
	
	for (unsigned int i = 0; i < clipCount; i++)
	{
		com_ptr<IBMDSwitcherClip> clip;
		if (mediaPool->GetClip(i, clip.releaseAndGetAddressOf()) == S_OK)
		{
			bool isValid;
			if ((clip->IsValid(&isValid) == S_OK) && isValid)
			{
				CFStringRef	clipName;
				uint32_t	clipIndex;
				uint32_t	clipFrameCount;
				if ((clip->GetName(&clipName) == S_OK) &&
					(clip->GetIndex(&clipIndex) == S_OK) &&
					(clip->GetFrameCount(&clipFrameCount) == S_OK))
					printf(" %-7d%-40s%u\n", clipIndex, CFStringToStdString(clipName).c_str(), clipFrameCount);
			}
		}
	}
	printf("\n");
}
