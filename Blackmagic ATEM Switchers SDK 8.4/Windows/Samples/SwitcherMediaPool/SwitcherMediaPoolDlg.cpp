/* -LICENSE-START-
** Copyright (c) 2012 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "stdafx.h"
#include "SwitcherMediaPool.h"
#include "SwitcherMediaPoolDlg.h"
#include "CallbackMonitors.h"
#include "MediaPoolTransfer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CSwitcherMediaPoolDlg::CSwitcherMediaPoolDlg(CWnd* pParent /*=NULL*/)
 :	CDialog(CSwitcherMediaPoolDlg::IDD, pParent),
	mSwitcherDiscovery(NULL),
	mSwitcher(NULL),
	mMediaPool(NULL),
	mStills(NULL),
	mSwitcherMonitor(NULL),
	mMediaPlayer1Monitor(NULL),
	mStillsMonitor(NULL),
	mStillTransfer(NULL)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

CSwitcherMediaPoolDlg::~CSwitcherMediaPoolDlg()
{
	cleanUpConnection();

	delete mMediaPlayer1Monitor;
	mMediaPlayer1Monitor = NULL;

	delete mStillsMonitor;
	mStillsMonitor = NULL;

	delete mSwitcherMonitor;
	mSwitcherMonitor = NULL;

	if (mSwitcherDiscovery)
	{
		mSwitcherDiscovery->Release();
		mSwitcherDiscovery = NULL;
	}
}

void CSwitcherMediaPoolDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);

	// get references to widgets

	// connection / name widgets
	DDX_Control(pDX, IDC_EDIT_ADDRESS, mAddressEdit);
	DDX_Control(pDX, IDC_BUTTON_CONNECT, mConnectButton);
	DDX_Control(pDX, IDC_EDIT_NAME, mNameEdit);

	// media player widgets
	DDX_Control(pDX, IDC_COMBO_MEDIA_PLAYER, mMediaPlayerSourceCombo);
	DDX_Control(pDX, IDC_BUTTON_BEGIN, mMediaPlayerBeginButton);
	DDX_Control(pDX, IDC_BUTTON_PREVIOUS, mMediaPlayerPreviousButton);
	DDX_Control(pDX, IDC_BUTTON_PLAY, mMediaPlayerPlayButton);
	DDX_Control(pDX, IDC_BUTTON_NEXT, mMediaPlayerNextButton);
	DDX_Control(pDX, IDC_BUTTON_LOOP, mMediaPlayerLoopButton);

	// media pool widgets
	DDX_Control(pDX, IDC_COMBO_MEDIA_POOL, mMediaPoolTargetCombo);
	DDX_Control(pDX, IDC_BUTTON_UPLOAD, mMediaPoolUploadButton);
	DDX_Control(pDX, IDC_LABEL_PROGRESS, mMediaPoolProgressLabel);
}

BEGIN_MESSAGE_MAP(CSwitcherMediaPoolDlg, CDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP

	// callbacks for receiving our application defined messages
	ON_MESSAGE(WM_SWITCHER_DISCONNECTED, OnSwitcherDisconnected)
	ON_MESSAGE(WM_MEDIA_PLAYER_SOURCE_CHANGED, OnMediaPlayerSourceChanged)
	ON_MESSAGE(WM_MEDIA_PLAYER_PLAYING_CHANGED, OnMediaPlayerPlayingChanged)
	ON_MESSAGE(WM_MEDIA_PLAYER_LOOP_CHANGED, OnMediaPlayerLoopChanged)
	ON_MESSAGE(WM_MEDIA_PLAYER_BEGIN_CHANGED, OnMediaPlayerBeginChanged)
	ON_MESSAGE(WM_STILL_NAME_VALID_CHANGED, OnStillClipNameValidChanged)
	ON_MESSAGE(WM_CLIP_NAME_VALID_CHANGED, OnStillClipNameValidChanged)
	ON_MESSAGE(WM_STILLS_LOCK_OBTAINED, OnStillsLockObtained)
	ON_MESSAGE(WM_CLIP_LOCK_OBTAINED, OnClipLockObtained)
	ON_MESSAGE(WM_STILLS_TRANSFER_ENDED, OnStillsTransferEnded)
	ON_MESSAGE(WM_CLIP_TRANSFER_ENDED, OnClipTransferEnded)

	// widget callbacks
	ON_BN_CLICKED(IDC_BUTTON_CONNECT, &CSwitcherMediaPoolDlg::OnConnectButtonClicked)
	ON_CBN_SELENDOK(IDC_COMBO_MEDIA_PLAYER, &CSwitcherMediaPoolDlg::OnMediaPlayerSourceComboChanged)
	ON_BN_CLICKED(IDC_BUTTON_BEGIN, &CSwitcherMediaPoolDlg::OnBeginButtonClicked)
	ON_BN_CLICKED(IDC_BUTTON_PREVIOUS, &CSwitcherMediaPoolDlg::OnPreviousButtonClicked)
	ON_BN_CLICKED(IDC_BUTTON_PLAY, &CSwitcherMediaPoolDlg::OnPlayButtonClicked)
	ON_BN_CLICKED(IDC_BUTTON_NEXT, &CSwitcherMediaPoolDlg::OnNextButtonClicked)
	ON_BN_CLICKED(IDC_BUTTON_LOOP, &CSwitcherMediaPoolDlg::OnLoopButtonClicked)
	ON_CBN_SELENDOK(IDC_COMBO_MEDIA_POOL, &CSwitcherMediaPoolDlg::OnMediaPoolTargetComboChanged)
	ON_BN_CLICKED(IDC_BUTTON_UPLOAD, &CSwitcherMediaPoolDlg::OnUploadButtonClicked)
END_MESSAGE_MAP()

// CSwitcherMediaPoolDlg message handlers

BOOL CSwitcherMediaPoolDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog. The framework does this automatically
	// when the application's main window is not a dialog.
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	// initialize COM and Switcher related members
	if (FAILED(CoInitialize(NULL)))
	{
		MessageBox(_T("CoInitialize failed"), _T("Error"));
		goto finish;
	}

	mSwitcherMonitor = new SwitcherMonitor(m_hWnd);
	mMediaPlayer1Monitor = new MediaPlayerMonitor(m_hWnd);
	mStillsMonitor = new StillsMonitor(m_hWnd);

	HRESULT hr = CoCreateInstance(CLSID_CBMDSwitcherDiscovery, NULL, CLSCTX_ALL, IID_IBMDSwitcherDiscovery, (void**)&mSwitcherDiscovery);
	if (FAILED(hr))
	{
		MessageBox(_T("Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed."), _T("Error"));
		goto finish;
	}

	switcherDisconnected();		// start with switcher disconnected

	return TRUE;				// return TRUE unless you set the focus to a control

finish:
	return FALSE;
}

void CSwitcherMediaPoolDlg::OnConnectButtonClicked()
{
	BMDSwitcherConnectToFailure failReason;
	CString address;
	BSTR addressBstr = NULL;

	// get the address from the UI
	mAddressEdit.GetWindowText(address);
	addressBstr = address.AllocSysString();

	// ensure we have cleaned up an existing connection
	cleanUpConnection();

	// Note that ConnectTo() can take several seconds to return, both for success or failure,
	// depending upon hostname resolution and network response times, so it may be best to
	// do this in a separate thread to prevent the main GUI thread blocking.
	HRESULT hr = mSwitcherDiscovery->ConnectTo(addressBstr, &mSwitcher, &failReason);
	
	if (SUCCEEDED(hr))
	{
		switcherConnected();
	}
	else
	{
		// display connection failures with a message box
		switch (failReason)
		{
			case bmdSwitcherConnectToFailureNoResponse:
				MessageBox(_T("No response from Switcher"), _T("Error"));
				break;
			case bmdSwitcherConnectToFailureIncompatibleFirmware:
				MessageBox(_T("Switcher has incompatible firmware"), _T("Error"));
				break;
			default:
				MessageBox(_T("Connection failed for unknown reason"), _T("Error"));
				break;
		}
	}

	if (addressBstr)
		SysFreeString(addressBstr);
}

void CSwitcherMediaPoolDlg::OnMediaPlayerSourceComboChanged()
{
	HRESULT result;
	unsigned int clipCount;
	BMDSwitcherMediaPlayerSourceType sourceType;
	int sourceIndex;
	unsigned int comboIndex = mMediaPlayerSourceCombo.GetCurSel();

	// check we have the media pool
	if (! mMediaPool)
	{
		TRACE(_T("No media pool\n"));
		return;
	}

	// get the clip count
	result = mMediaPool->GetClipCount(&clipCount);
	if (FAILED(result))
	{
		TRACE(_T("Could not get clip count\n"));
		return;
	}

	// determine if source is clip or still
	if (comboIndex < clipCount)
	{
		// source is a clip
		sourceType = bmdSwitcherMediaPlayerSourceTypeClip;
		sourceIndex = comboIndex;
	}
	else
	{
		// source is a still
		sourceType = bmdSwitcherMediaPlayerSourceTypeStill;
		sourceIndex = comboIndex - clipCount;
	}

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return;
	}

	// set media player 1 source
	result = mMediaPlayers[0]->SetSource(sourceType, sourceIndex);
	if (FAILED(result))
	{
		TRACE(_T("Could not set media player 1 source\n"));
		return;
	}
}

void CSwitcherMediaPoolDlg::OnMediaPoolTargetComboChanged()
{
	// the media pool combo box selected item has changed
	updateMediaPoolComboSelection();
}

void CSwitcherMediaPoolDlg::OnUploadButtonClicked()
{
	unsigned int comboIndex = mMediaPoolTargetCombo.GetCurSel();
	bool uploadStarted = false;

	// disable the upload button immediately
	mMediaPoolUploadButton.EnableWindow(FALSE);

	// determine if the upload target is a still or clip
	if (comboIndex < mClips.size())
	{
		// target is a clip
		
		if (comboIndex >= mClipTransfers.size())
		{
			TRACE(_T("No clip transfer for this clip index\n"));
			return;
		}

		// in this example application we only support tga files and we do not support the full tga specification
		// this means that some tga files will not be uploadable
		TCHAR fileFilters[]= _T("TGA File (*.tga)|*.tga||");

		// open dialog
		CFileDialog fileDlg(TRUE, _T("tga"), _T("*.tga"), OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, fileFilters);

		// the following dialog modification is required to support the selection of multiple files
		CString fileDlgBuff;
		const int fileDlgMaxFiles = 10000;
		const int fileDlgBuffSize = (fileDlgMaxFiles * (MAX_PATH + 1)) + 1;
		fileDlg.GetOFN().lpstrFile = fileDlgBuff.GetBuffer(fileDlgBuffSize);
		fileDlg.GetOFN().nMaxFile = fileDlgMaxFiles;

		if (fileDlg.DoModal() == IDOK)
		{
			// the user has selected at least one file and has clicked the open button
			std::list<CString> filePaths;

			// get selected files
			POSITION startPos = fileDlg.GetStartPosition();
			while (startPos)
				filePaths.push_back(fileDlg.GetNextPathName(startPos));

			// show the progress label as the upload method can block for a short time
			mMediaPoolProgressLabel.ShowWindow(SW_SHOW);
			mMediaPoolProgressLabel.UpdateWindow(); // we want to see the label immediately

			// upload the files selected by the user to the clip
			uploadStarted = mClipTransfers[comboIndex]->upload(filePaths);
		}
	}
	else
	{
		// target is a still
		
		if (! mStillTransfer)
		{
			TRACE(_T("No still transfer\n"));
			return;
		}

		// in this example application we only support tga files and we do not support the full tga specification
		// this means that some tga files will not be uploadable
		TCHAR fileFilters[]= _T("TGA File (*.tga)|*.tga||");

		// open dialog
		CFileDialog fileDlg(TRUE, _T("tga"), _T("*.tga"), OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST, fileFilters);

		if (fileDlg.DoModal() == IDOK)
		{
			// the user has clicked OK

			// show the progress label as the upload method can block for a short time
			mMediaPoolProgressLabel.ShowWindow(SW_SHOW);
			mMediaPoolProgressLabel.UpdateWindow(); // we want to see the label immediately

			// upload the file selected by the user to the still
			uploadStarted = mStillTransfer->upload(comboIndex - mClips.size(), fileDlg.GetPathName());
		}
	}

	if (! uploadStarted)
	{
		// upload failed to start
		mMediaPoolUploadButton.EnableWindow(TRUE);		// re-enable the upload button
		mMediaPoolProgressLabel.ShowWindow(SW_HIDE);	// hide the progress label
	}
}

void CSwitcherMediaPoolDlg::cleanUpConnection()
{
	// disconnect monitors
	mSwitcherMonitor->setSwitcher(NULL);
	mMediaPlayer1Monitor->setMediaPlayer(NULL);
	mStillsMonitor->setStills(NULL);

	// we delete clip monitors because they
	// are created and set on every connection
	while (mClipMonitors.size())
	{
		delete mClipMonitors.back();
		mClipMonitors.pop_back();
	}

	// free connected switcher interfaces

	while (mMediaPlayers.size())
	{
		mMediaPlayers.back()->Release();
		mMediaPlayers.pop_back();
	}

	while (mClips.size())
	{
		mClips.back()->Release();
		mClips.pop_back();
	}

	if (mStills)
	{
		mStills->Release();
		mStills = NULL;
	}

	if (mMediaPool)
	{
		mMediaPool->Release();
		mMediaPool = NULL;
	}

	if (mSwitcher)
	{
		mSwitcher->Release();
		mSwitcher = NULL;
	}

	// free still transfer
	delete mStillTransfer;
	mStillTransfer = NULL;

	// free clip transfers
	while (mClipTransfers.size())
	{
		delete mClipTransfers.back();
		mClipTransfers.pop_back();
	}
}

void CSwitcherMediaPoolDlg::switcherConnected()
{
	HRESULT result;
	IBMDSwitcherMediaPlayerIterator* mediaPlayerIterator = NULL;
	unsigned int clipCount;

	// update UI enabled states
	mConnectButton.EnableWindow(FALSE);	// disable Connect button while connected
	mMediaPlayerSourceCombo.EnableWindow(TRUE);
	enableMediaPlayerButtons(TRUE);
	enableMediaPoolWidgets(TRUE);

	// get the product name
	BSTR productName;
	if (FAILED(mSwitcher->GetProductName(&productName)))
	{
		TRACE(_T("Could not get switcher product name\n"));
		return;
	}
	CString productNameCString(productName);
	SysFreeString(productName);

	// set the product name for the UI
	mNameEdit.SetWindowText(productNameCString);

	// get the media player iterator
	result = mSwitcher->CreateIterator(IID_IBMDSwitcherMediaPlayerIterator, (void**)&mediaPlayerIterator);
	if (FAILED(result))
	{
		TRACE(_T("Could not create IBMDSwitcherMediaPlayerIterator iterator\n"));
		goto finish;
	}

	// get all media players
	while (true)
	{
		IBMDSwitcherMediaPlayer* mediaPlayer = NULL;
		result = mediaPlayerIterator->Next(&mediaPlayer);
		if (result != S_OK)
			break;

		mMediaPlayers.push_back(mediaPlayer);
	}

	if (FAILED(result))
	{
		TRACE(_T("Could not iterate media players\n"));
		goto finish;
	}

	// get media pool
	result = mSwitcher->QueryInterface(IID_IBMDSwitcherMediaPool, (void**)&mMediaPool);
	if (FAILED(result))
	{
		TRACE(_T("Could not get IBMDSwitcherMediaPool interface\n"));
		goto finish;
	}

	// get stills interface
	result = mMediaPool->GetStills(&mStills);
	if (FAILED(result))
	{
		TRACE(_T("Could not get IBMDSwitcherStills interface\n"));
		goto finish;
	}

	// get number of clips
	result = mMediaPool->GetClipCount(&clipCount);
	if (FAILED(result))
	{
		TRACE(_T("Could not get clip count\n"));
		goto finish;
	}

	// get all clip interfaces
	for (unsigned int clipIndex = 0; clipIndex < clipCount; ++clipIndex)
	{
		IBMDSwitcherClip* clip = NULL;

		result = mMediaPool->GetClip(clipIndex, &clip);
		if (FAILED(result))
		{
			TRACE(_T("Could not get clip interface\n"));
			goto finish;
		}

		mClips.push_back(clip);
	}

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		goto finish;
	}

	// set monitors, which will flush the callbacks and update the GUI
	mSwitcherMonitor->setSwitcher(mSwitcher);
	mMediaPlayer1Monitor->setMediaPlayer(mMediaPlayers[0]);
	mStillsMonitor->setStills(mStills);

	if (mClipMonitors.size() > 0)
		TRACE(_T("Clip monitors have not been deleted\n"));

	// create clip monitors here because we don't know clip count on initialization
	for (unsigned int clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
	{
		ClipMonitor* clipMonitor = new ClipMonitor(m_hWnd);
		clipMonitor->setClip(mClips[clipIndex]);
		mClipMonitors.push_back(clipMonitor);
	}

	// create still transfer
	mStillTransfer = new StillTransfer(m_hWnd, mSwitcher, mMediaPool, mStills);

	// create clip transfers
	for (unsigned int clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
	{
		ClipTransfer* clipTransfer = new ClipTransfer(m_hWnd, mSwitcher, mMediaPool, mClips[clipIndex]);
		mClipTransfers.push_back(clipTransfer);
	}

finish:
	if (mediaPlayerIterator)
		mediaPlayerIterator->Release();
}

void CSwitcherMediaPoolDlg::switcherDisconnected()
{
	enableMediaPlayerButtons(FALSE);
	enableMediaPoolWidgets(FALSE);
	cleanUpConnection();

	mConnectButton.EnableWindow(TRUE);		// enable connect button so user can re-connect
	mMediaPlayerSourceCombo.EnableWindow(FALSE);

	mNameEdit.SetWindowText(_T(""));
}

//
// GUI updates
//
void CSwitcherMediaPoolDlg::updateMediaComboItems(CComboBox* comboBox)
{
	HRESULT result;
	unsigned int stillCount;
	int comboIndex = comboBox->GetCurSel(); // save current index

	// check we have the media pool
	if (! mMediaPool)
	{
		TRACE(_T("No media pool\n"));
		return;
	}

	// clear existing combo box items
	comboBox->ResetContent();

	// append a combox box item for each clip
	for (unsigned int clipIndex = 0; clipIndex < mClips.size(); ++clipIndex)
	{
		BSTR clipName = NULL;
		IBMDSwitcherClip* clip = mClips[clipIndex];

		// if the clip is invalid, the clip name will be blank
		result = clip->GetName(&clipName);
		if (FAILED(result))
		{
			TRACE(_T("Could not get clip name\n"));
			return;
		}

		// add the clip item
		CString clipNameCString;
		clipNameCString.Format(_T(" Clip %d: %s"), clipIndex + 1, clipName);
		comboBox->AddString(clipNameCString);

		SysFreeString(clipName);
	}

	// check we have stills
	if (! mStills)
	{
		TRACE(_T("No stills\n"));
		return;
	}

	// get the number of stills
	result = mStills->GetCount(&stillCount);
	if (FAILED(result))
	{
		TRACE(_T("Could not get still count\n"));
		return;
	}

	// append a combo box item for each still
	for (unsigned int stillIndex = 0; stillIndex < stillCount; ++stillIndex)
	{
		BSTR stillName = NULL;

		// if the still is invalid, the still name will be blank
		result = mStills->GetName(stillIndex, &stillName);
		if (FAILED(result))
		{
			TRACE(_T("Could not get still name\n"));
			return;
		}

		// add the still item
		CString stillNameCString;
		stillNameCString.Format(_T(" Still %d: %s"), stillIndex + 1, stillName);
		comboBox->AddString(stillNameCString);

		SysFreeString(stillName);
	}

	// restore previously selected index
	comboBox->SetCurSel(comboIndex);
}

void CSwitcherMediaPoolDlg::updateMediaPlayerComboSelection()
{
	// This method sets the media player combo box selected
	// item to the source of the media player and sets the
	// media player buttons enabled if the selected item is a clip.

	HRESULT result;
	BMDSwitcherMediaPlayerSourceType sourceType;
	unsigned int sourceIndex;
	BOOL valid = FALSE;

	// check we have the media pool
	if (! mMediaPool)
	{
		TRACE(_T("No media pool\n"));
		return;
	}

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return;
	}

	// get the source
	result = mMediaPlayers[0]->GetSource(&sourceType, &sourceIndex);
	if (FAILED(result))
	{
		TRACE(_T("Could not get media player source\n"));
		return;
	}

	// set the combo to the media player source
	if (sourceType == bmdSwitcherMediaPlayerSourceTypeClip)
	{
		int comboIndex = sourceIndex; // clip items are listed first in the combo box

		// check the clip index is valid
		if (sourceIndex >= (int)mClips.size())
		{
			TRACE(_T("Invalid clip selection\n"));
			return;
		}

		// only enable media player buttons if the clip is valid
		result = mClips[sourceIndex]->IsValid(&valid);
		if (FAILED(result))
		{
			TRACE(_T("Could not get clip validity\n"));
			return;
		}

		mMediaPlayerSourceCombo.SetCurSel(comboIndex);
	}
	else if (sourceType == bmdSwitcherMediaPlayerSourceTypeStill)
	{
		unsigned int comboIndex = mClips.size() + sourceIndex; // still items are listed second in the combo box
		unsigned int stillCount;

		// get the number of stills
		result = mStills->GetCount(&stillCount);
		if (FAILED(result))
		{
			TRACE(_T("Could not get still count\n"));
			return;
		}

		// check the still index is valid
		if (sourceIndex >= stillCount)
		{
			TRACE(_T("Invalid still selection\n"));
			return;
		}

		mMediaPlayerSourceCombo.SetCurSel(comboIndex);
	}
	else
	{
		TRACE(_T("Unknown media player source type\n"));
		return;
	}

	enableMediaPlayerButtons(valid);
}

void CSwitcherMediaPoolDlg::enableMediaPlayerButtons(BOOL enabled)
{
	// sets the media player button widgets enabled state
	mMediaPlayerBeginButton.EnableWindow(enabled);
	mMediaPlayerPreviousButton.EnableWindow(enabled);
	mMediaPlayerPlayButton.EnableWindow(enabled);
	mMediaPlayerNextButton.EnableWindow(enabled);
	mMediaPlayerLoopButton.EnableWindow(enabled);

	if (! enabled)
	{
		// checked buttons appear enabled, so uncheck them
		mMediaPlayerBeginButton.SetCheck(FALSE);
		mMediaPlayerPreviousButton.SetCheck(FALSE);
		mMediaPlayerPlayButton.SetCheck(FALSE);
		mMediaPlayerNextButton.SetCheck(FALSE);
		mMediaPlayerLoopButton.SetCheck(FALSE);
	}
}

void CSwitcherMediaPoolDlg::enableMediaPoolWidgets(BOOL enabled)
{
	// sets the media pool widgets enabled state
	mMediaPoolTargetCombo.EnableWindow(enabled);
	mMediaPoolUploadButton.EnableWindow(enabled);
}

void CSwitcherMediaPoolDlg::updateMediaPoolComboSelection()
{
	// This method sets the media pool combo box
	// selected item if it is not already set

	int comboIndex = mMediaPoolTargetCombo.GetCurSel();
	if (comboIndex < 0)
		mMediaPoolTargetCombo.SetCurSel(0);
}

LRESULT CSwitcherMediaPoolDlg::OnSwitcherDisconnected(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// the switcher has disconnected

	switcherDisconnected();
	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnMediaPlayerSourceChanged(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// the source has changed

	// update the selected source
	updateMediaPlayerComboSelection();

	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnMediaPlayerPlayingChanged(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// the switcher has notified us that the playing property has changed

	BOOL playing;
	HRESULT result;

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return 0;
	}

	// get the playing property
	result = mMediaPlayers[0]->GetPlaying(&playing);
	if (FAILED(result))
	{
		TRACE(_T("Could not get playing\n"));
		return 0;
	}

	// update the state of the button
	// checked buttons appear enabled, so don't check them unless enabled
	mMediaPlayerPlayButton.SetCheck(playing && mMediaPlayerPlayButton.IsWindowEnabled());

	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnMediaPlayerBeginChanged(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// the switcher has notified us that the 'at beginning' property has changed

	BOOL atBegining;
	HRESULT result;

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return 0;
	}

	// get the 'at beginning' property
	result = mMediaPlayers[0]->GetAtBeginning(&atBegining);
	if (FAILED(result))
	{
		TRACE(_T("Could not get 'at beginning'\n"));
		return 0;
	}

	// update the state of the button
	// checked buttons appear enabled, so don't check them unless enabled
	mMediaPlayerBeginButton.SetCheck(atBegining && mMediaPlayerBeginButton.IsWindowEnabled());

	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnMediaPlayerLoopChanged(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// the switcher has notified us that the loop property has changed

	BOOL loop;
	HRESULT result;

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return 0;
	}

	// get the loop property
	result = mMediaPlayers[0]->GetLoop(&loop);
	if (FAILED(result))
	{
		TRACE(_T("Could not get loop\n"));
		return 0;
	}

	// update the state of the button
	// checked buttons appear enabled, so don't check them unless enabled
	mMediaPlayerLoopButton.SetCheck(loop && mMediaPlayerLoopButton.IsWindowEnabled());

	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnStillClipNameValidChanged(WPARAM wParam, LPARAM /*lParam*/)
{
	// If the drop down is visible, the items will not be updated
	// The workaround is to close the drop down
	mMediaPlayerSourceCombo.ShowDropDown(FALSE);

	// We could update only the item that has changed, but this is simpler
	updateMediaComboItems(&mMediaPlayerSourceCombo);
	updateMediaPlayerComboSelection();
	updateMediaComboItems(&mMediaPoolTargetCombo);
	updateMediaPoolComboSelection();

	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnStillsLockObtained(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	// lock has been obtained on stills

	if (mStillTransfer)
	{
		// pass the message through to the still transfer
		mStillTransfer->onLockObtained();
	}

	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnClipLockObtained(WPARAM wParam, LPARAM /*lParam*/)
{
	// lock has been obtained on a clip

	int clipIndex = static_cast<int>(wParam);

	if (clipIndex < (int)mClips.size())
	{
		// pass the message through to the clip transfer
		mClipTransfers[clipIndex]->onLockObtained();
	}

	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnStillsTransferEnded(WPARAM wParam, LPARAM lParam)
{
	// a still transfer has ended
	bool success = static_cast<bool>(wParam != 0);

	if (! mStillTransfer)
	{
		TRACE(_T("No still transfer interface\n"));
		goto finish;
	}

	// pass message through to the still transfer
	mStillTransfer->onTransferEnded(success);

	// enable the upload button now that the transfer has ended
	mMediaPoolUploadButton.EnableWindow(TRUE);

	// hide progress label
	mMediaPoolProgressLabel.ShowWindow(SW_HIDE);

finish:
	return 0;
}

LRESULT CSwitcherMediaPoolDlg::OnClipTransferEnded(WPARAM wParam, LPARAM lParam)
{
	// a still transfer has ended

	bool success = static_cast<bool>(wParam != 0);
	int clipIndex = static_cast<int>(lParam);

	if (clipIndex >= (int)mClips.size())
	{
		TRACE(_T("No clip interface for clip index\n"));
		goto finish;
	}

	// pass message through to the clip transfer
	if (mClipTransfers[clipIndex]->onTransferEnded(success))
	{
		// enable the upload button now that the transfer has ended
		mMediaPoolUploadButton.EnableWindow(TRUE);

		// hide progress label
		mMediaPoolProgressLabel.ShowWindow(SW_HIDE);
	}

finish:
	return 0;
}

void CSwitcherMediaPoolDlg::OnBeginButtonClicked()
{
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return;
	}

	// toggle the 'at beginning' property, the button state will change upon notification from the switcher
	HRESULT result = mMediaPlayers[0]->SetAtBeginning();
	if (FAILED(result))
	{
		TRACE(_T("Could not set 'at beginning'\n"));
		return;
	}
}

void CSwitcherMediaPoolDlg::OnPreviousButtonClicked()
{
	HRESULT result;
	unsigned int clipFrameIndex;
	unsigned int clipIndex = mMediaPlayerSourceCombo.GetCurSel();

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return;
	}

	// check we have the clip
	if (clipIndex > mClips.size())
	{
		TRACE(_T("No valid clip selected\n"));
		return;
	}

	// get the clip frame index
	result = mMediaPlayers[0]->GetClipFrame(&clipFrameIndex);
	if (FAILED(result))
	{
		TRACE(_T("Could not get clip frame index\n"));
		return;
	}

	// we can't goto the previous frame if we are on the first frame
	if (clipFrameIndex > 0)
	{
		// set clip frame index to previous frame
		result = mMediaPlayers[0]->SetClipFrame(clipFrameIndex - 1);
		if (FAILED(result))
		{
			TRACE(_T("Could not set clip frame index\n"));
			return;
		}
	}
}

void CSwitcherMediaPoolDlg::OnPlayButtonClicked()
{
	HRESULT result;
	BOOL playing;

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return;
	}

	// get the playing property
	result = mMediaPlayers[0]->GetPlaying(&playing);
	if (FAILED(result))
	{
		TRACE(_T("Could not get playing\n"));
		return;
	}

	// toggle the playing property, the button state will change upon notification from the switcher
	result = mMediaPlayers[0]->SetPlaying(! playing);
	if (FAILED(result))
	{
		TRACE(_T("Could not set playing\n"));
		return;
	}
}

void CSwitcherMediaPoolDlg::OnNextButtonClicked()
{
	HRESULT result;
	unsigned int clipFrameCount;
	unsigned int clipFrameIndex;
	unsigned int clipIndex = mMediaPlayerSourceCombo.GetCurSel();

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return;
	}

	// check we have the clip
	if (clipIndex > mClips.size())
	{
		TRACE(_T("No valid clip selected\n"));
		return;
	}

	// check we have the clip
	result = mClips[clipIndex]->GetFrameCount(&clipFrameCount);
	if (FAILED(result))
	{
		TRACE(_T("Could not get clip frame count\n"));
		return;
	}

	// get the clip frame index
	result = mMediaPlayers[0]->GetClipFrame(&clipFrameIndex);
	if (FAILED(result))
	{
		TRACE(_T("Could not get clip frame index\n"));
		return;
	}

	// we can't goto the next frame if we are on the last frame
	if (++clipFrameIndex < clipFrameCount)
	{
		// set clip frame index to previous frame
		result = mMediaPlayers[0]->SetClipFrame(clipFrameIndex);
		if (FAILED(result))
		{
			TRACE(_T("Could not set clip frame index\n"));
			return;
		}
	}
}

void CSwitcherMediaPoolDlg::OnLoopButtonClicked()
{
	HRESULT result;
	BOOL loop;

	// check we have media player 1
	if (mMediaPlayers.size() < 1)
	{
		TRACE(_T("No media player 1\n"));
		return;
	}

	// get the loop property
	result = mMediaPlayers[0]->GetLoop(&loop);
	if (FAILED(result))
	{
		TRACE(_T("Could not get loop\n"));
		return;
	}

	// toggle the loop property, the button state will change upon notification from the switcher
	result = mMediaPlayers[0]->SetLoop(! loop);
	if (FAILED(result))
	{
		TRACE(_T("Could not set loop\n"));
		return;
	}
}
