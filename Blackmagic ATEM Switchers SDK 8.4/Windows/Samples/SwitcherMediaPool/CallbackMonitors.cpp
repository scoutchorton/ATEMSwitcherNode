/* -LICENSE-START-
** Copyright (c) 2012 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "stdafx.h"
#include "CallbackMonitors.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// ----------------------------------------------------------

MediaPlayerCallback::MediaPlayerCallback(HWND hWnd)
 :	mHWnd(hWnd),
	mRefCount(1)
{
}

HRESULT MediaPlayerCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	if (!ppv)
		return E_POINTER;

	if (IsEqualGUID(iid, IID_IBMDSwitcherMediaPlayerCallback))
	{
		*ppv = static_cast<IBMDSwitcherMediaPlayerCallback*>(this);
		AddRef();
		return S_OK;
	}

	if (IsEqualGUID(iid, IID_IUnknown))
	{
		*ppv = static_cast<IUnknown*>(this);
		AddRef();
		return S_OK;
	}

	*ppv = NULL;
	return E_NOINTERFACE;
}

ULONG MediaPlayerCallback::AddRef(void)
{
	return InterlockedIncrement(&mRefCount);
}

ULONG MediaPlayerCallback::Release(void)
{
	int newCount = InterlockedDecrement(&mRefCount);
	if (newCount == 0)
		delete this;
	return newCount;
}

HRESULT MediaPlayerCallback::SourceChanged(void)
{
	PostMessage(mHWnd, WM_MEDIA_PLAYER_SOURCE_CHANGED, NULL, NULL);
	return S_OK;
}

HRESULT MediaPlayerCallback::PlayingChanged(void)
{
	PostMessage(mHWnd, WM_MEDIA_PLAYER_PLAYING_CHANGED, NULL, NULL);
	return S_OK;
}

HRESULT MediaPlayerCallback::LoopChanged(void)
{
	PostMessage(mHWnd, WM_MEDIA_PLAYER_LOOP_CHANGED, NULL, NULL);
	return S_OK;
}  

HRESULT MediaPlayerCallback::AtBeginningChanged(void)
{
	PostMessage(mHWnd, WM_MEDIA_PLAYER_BEGIN_CHANGED, NULL, NULL);
	return S_OK;
}  

HRESULT MediaPlayerCallback::ClipFrameChanged(void)
{
	return S_OK;
}

MediaPlayerCallback::~MediaPlayerCallback()
{
}

// ----------------------------------------------------------

MediaPlayerMonitor::MediaPlayerMonitor(HWND hWnd)
 :	mMediaPlayer(NULL)
{
	mCallback = new MediaPlayerCallback(hWnd);
}

MediaPlayerMonitor::~MediaPlayerMonitor()
{
	setMediaPlayer(NULL);
	mCallback->Release();
}

void MediaPlayerMonitor::setMediaPlayer(IBMDSwitcherMediaPlayer* mediaPlayer)
{
	if (mMediaPlayer)
	{
		mMediaPlayer->RemoveCallback(mCallback);
		mMediaPlayer->Release();
	}

	mMediaPlayer = mediaPlayer;
	if (mMediaPlayer)
	{
		mMediaPlayer->AddRef();
		mMediaPlayer->AddCallback(mCallback);

		// we flush callbacks here to update the state of the listeners
		flush();
	}
}

void MediaPlayerMonitor::flush()
{
	mCallback->SourceChanged();
	mCallback->PlayingChanged();
	mCallback->LoopChanged();
	mCallback->AtBeginningChanged();
}

// ----------------------------------------------------------

StillsCallback::StillsCallback(HWND hWnd)
 :	mHWnd(hWnd),
	mRefCount(1)
{
}

HRESULT StillsCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	if (!ppv)
		return E_POINTER;

	if (IsEqualGUID(iid, IID_IBMDSwitcherStillsCallback))
	{
		*ppv = static_cast<IBMDSwitcherStillsCallback*>(this);
		AddRef();
		return S_OK;
	}

	if (IsEqualGUID(iid, IID_IUnknown))
	{
		*ppv = static_cast<IUnknown*>(this);
		AddRef();
		return S_OK;
	}

	*ppv = NULL;
	return E_NOINTERFACE;
}

ULONG StillsCallback::AddRef(void)
{
	return InterlockedIncrement(&mRefCount);
}

ULONG StillsCallback::Release(void)
{
	int newCount = InterlockedDecrement(&mRefCount);
	if (newCount == 0)
		delete this;
	return newCount;
}

HRESULT StillsCallback::Notify(BMDSwitcherMediaPoolEventType eventType, IBMDSwitcherFrame* /*frame*/, int index)
{
	// This example supports uploading only so we don't use the frame.
	// If you need to use the frame outside of the scope of this method then you must
	// add a reference to it to prevent it from being released.

	switch (eventType)
	{
		// when a still becomes invalid we need to clear the name, so we post both together
		case bmdSwitcherMediaPoolEventTypeValidChanged:
		case bmdSwitcherMediaPoolEventTypeNameChanged:
		{
			PostMessage(mHWnd, WM_STILL_NAME_VALID_CHANGED, (WPARAM)index, NULL);
		}
		break;

		case bmdSwitcherMediaPoolEventTypeTransferCompleted:
		case bmdSwitcherMediaPoolEventTypeTransferCancelled:
		case bmdSwitcherMediaPoolEventTypeTransferFailed:
		{
			bool success = (eventType == bmdSwitcherMediaPoolEventTypeTransferCompleted);

			PostMessage(mHWnd, WM_STILLS_TRANSFER_ENDED, (WPARAM)success, NULL);
		}
		break;
	}

	return S_OK;
}

StillsCallback::~StillsCallback()
{
}

// ----------------------------------------------------------

StillsMonitor::StillsMonitor(HWND hWnd)
	:	mStills(NULL)
{
	mCallback = new StillsCallback(hWnd);
}

StillsMonitor::~StillsMonitor()
{
	setStills(NULL);
	mCallback->Release();
}

void StillsMonitor::setStills(IBMDSwitcherStills* stills)
{
	if (mStills)
	{
		mStills->RemoveCallback(mCallback);
		mStills->Release();
	}

	mStills = stills;
	if (mStills)
	{
		mStills->AddRef();
		mStills->AddCallback(mCallback);

		// we flush callbacks here to update the state of the listeners
		flush();
	}
}

void StillsMonitor::flush()
{
	// flushing one still is sufficient because our callback will update all
	// the callbacks update for either NameChanged or ValidChanged so we only flush name changed
	mCallback->Notify(bmdSwitcherMediaPoolEventTypeNameChanged, NULL, 0);
}

// ----------------------------------------------------------

ClipCallback::ClipCallback(HWND hWnd)
 :	mHWnd(hWnd),
	mRefCount(1)
{
}

HRESULT ClipCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	if (!ppv)
		return E_POINTER;

	if (IsEqualGUID(iid, IID_IBMDSwitcherClipCallback))
	{
		*ppv = static_cast<IBMDSwitcherClipCallback*>(this);
		AddRef();
		return S_OK;
	}

	if (IsEqualGUID(iid, IID_IUnknown))
	{
		*ppv = static_cast<IUnknown*>(this);
		AddRef();
		return S_OK;
	}

	*ppv = NULL;
	return E_NOINTERFACE;
}

ULONG ClipCallback::AddRef(void)
{
	return InterlockedIncrement(&mRefCount);
}

ULONG ClipCallback::Release(void)
{
	int newCount = InterlockedDecrement(&mRefCount);
	if (newCount == 0)
		delete this;
	return newCount;
}

HRESULT ClipCallback::Notify(BMDSwitcherMediaPoolEventType eventType,
							 IBMDSwitcherFrame *frame,
							 int frameIndex,
							 IBMDSwitcherAudio *audio,
							 int clipIndex)
{
	// This example supports uploading only so we don't use the frame.
	// If you need to use the frame outside of the scope of this method then you must
	// add a reference to it to prevent it from being released.

	switch (eventType)
	{
		// when a clip becomes invalid we need to clear the name, so we post both together
		case bmdSwitcherMediaPoolEventTypeNameChanged:
		case bmdSwitcherMediaPoolEventTypeValidChanged:
			PostMessage(mHWnd, WM_CLIP_NAME_VALID_CHANGED, NULL, NULL);
			break;

		case bmdSwitcherMediaPoolEventTypeTransferCompleted:
		case bmdSwitcherMediaPoolEventTypeTransferCancelled:
		case bmdSwitcherMediaPoolEventTypeTransferFailed:
		{
			bool success = (eventType == bmdSwitcherMediaPoolEventTypeTransferCompleted);

			PostMessage(mHWnd, WM_CLIP_TRANSFER_ENDED, (WPARAM)success, NULL);
		}
		break;
	}

	return S_OK;
}

ClipCallback::~ClipCallback()
{
}

// ----------------------------------------------------------

ClipMonitor::ClipMonitor(HWND hWnd)
	:	mClip(NULL)
{
	mCallback = new ClipCallback(hWnd);
}

ClipMonitor::~ClipMonitor()
{
	setClip(NULL);
	mCallback->Release();
}

void ClipMonitor::setClip(IBMDSwitcherClip* clip)
{
	if (mClip)
	{
		mClip->RemoveCallback(mCallback);
		mClip->Release();
	}

	mClip = clip;
	if (mClip)
	{
		mClip->AddRef();
		mClip->AddCallback(mCallback);

		// we flush callbacks here to update the state of the listeners
		flush();
	}
}

void ClipMonitor::flush()
{
	// we can't flush if we don't have a clip interface
	if (! mClip)
		return;

	unsigned int clipIndex;
	HRESULT result = mClip->GetIndex(&clipIndex);
	if (FAILED(result))
	{
		TRACE(_T("Could not get clip index\n"));
		return;
	}

	// the callbacks update for either NameChanged or ValidChanged so we only flush name changed
	mCallback->Notify(bmdSwitcherMediaPoolEventTypeNameChanged, NULL, -1, NULL, clipIndex);
}

// ----------------------------------------------------------

LockCallback::LockCallback(HWND hWnd, int clipIndex)
 :	mHWnd(hWnd),
	mRefCount(1),
	mClipIndex(clipIndex)
{
}

// IUnknown
HRESULT LockCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	if (!ppv)
		return E_POINTER;

	if (IsEqualGUID(iid, IID_IBMDSwitcherLockCallback))
	{
		*ppv = static_cast<IBMDSwitcherLockCallback*>(this);
		AddRef();
		return S_OK;
	}

	if (IsEqualGUID(iid, IID_IUnknown))
	{
		*ppv = static_cast<IUnknown*>(this);
		AddRef();
		return S_OK;
	}

	*ppv = NULL;
	return E_NOINTERFACE;
}

ULONG LockCallback::AddRef(void)
{
	return InterlockedIncrement(&mRefCount);
}

ULONG LockCallback::Release(void)
{
	int newCount = InterlockedDecrement(&mRefCount);
	if (newCount == 0)
		delete this;
	return newCount;
}

HRESULT LockCallback::Obtained()
{
	// post separate messages for stills and clips
	if (mClipIndex >= 0)
		PostMessage(mHWnd, WM_CLIP_LOCK_OBTAINED, (WPARAM)mClipIndex, NULL);
	else
		PostMessage(mHWnd, WM_STILLS_LOCK_OBTAINED, NULL, NULL);

	return S_OK;
}

// ----------------------------------------------------------

SwitcherCallback::SwitcherCallback(HWND hWnd)
 :	mHWnd(hWnd),
	mRefCount(1)
{
}

// IBMDSwitcherCallback interface
HRESULT SwitcherCallback::QueryInterface(REFIID iid, LPVOID *ppv)
{
	if (!ppv)
		return E_POINTER;

	if (IsEqualGUID(iid, IID_IBMDSwitcherCallback))
	{
		*ppv = static_cast<IBMDSwitcherCallback*>(this);
		AddRef();
		return S_OK;
	}

	if (IsEqualGUID(iid, IID_IUnknown))
	{
		*ppv = static_cast<IUnknown*>(this);
		AddRef();
		return S_OK;
	}

	*ppv = NULL;
	return E_NOINTERFACE;
}

ULONG SwitcherCallback::AddRef(void)
{
	return InterlockedIncrement(&mRefCount);
}

ULONG SwitcherCallback::Release(void)
{
	int newCount = InterlockedDecrement(&mRefCount);
	if (newCount == 0)
		delete this;
	return newCount;
}

HRESULT SwitcherCallback::Notify(BMDSwitcherEventType eventType, BMDSwitcherVideoMode coreVideoMode)
{
	if (eventType == bmdSwitcherEventTypeDisconnected)
	{
		PostMessage(mHWnd, WM_SWITCHER_DISCONNECTED, NULL, NULL);
	}
	
	return S_OK;
}

SwitcherCallback::~SwitcherCallback()
{
}

// ----------------------------------------------------------

SwitcherMonitor::SwitcherMonitor(HWND hWnd)
:	mSwitcher(NULL)
{
	mCallback = new SwitcherCallback(hWnd);
}

SwitcherMonitor::~SwitcherMonitor()
{
	setSwitcher(NULL);
	mCallback->Release();
}

void SwitcherMonitor::setSwitcher(IBMDSwitcher* switcher)
{
	if (mSwitcher)
	{
		mSwitcher->RemoveCallback(mCallback);
		mSwitcher->Release();
	}
	
	mSwitcher = switcher;
	if (mSwitcher)
	{
		mSwitcher->AddRef();
		mSwitcher->AddCallback(mCallback);
	}
}
