/* -LICENSE-START-
** Copyright (c) 2012 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "stdafx.h"
#include <cstdio>
#include <new>
#include "TGALoader.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// ----------------------------------------------------------

TGALoader::TGALoader(CString path)
 :	mValid(false),
	mImageData(NULL),
	mImageDataSize(0),
	mWidth(0),
	mHeight(0),
	mBitsPerPixel(0)
{
	FILE* file = NULL;
	TGAHeader header;
	TGAFooter footer;
	BOOL hasFooter = false;
	long fileSize;
	int result;

	// sanity check the TGA header and footer structs
	if ((sizeof(TGAHeader) != 18) || (sizeof(TGAFooter) != 26))
	{
		TRACE(_T("Incorrect header or footer size. Check struct padding and/or data type sizes.\n"));
		goto finish;
	}

	// open the file
	result = _wfopen_s(&file, path.GetString(), TEXT("rb"));
	if (result != 0)
	{
		TRACE(_T("Could not open file\n"));
		goto finish;
	}

	// load the header
	if (fread(&header, 1, sizeof(header), file) != sizeof(header))
	{
		TRACE(_T("Could not read image data\n"));
		goto finish;
	}

	// parse the header

	// ignore header.idLength

	if (header.colourMapType != 0)
	{
		TRACE(_T("Color maps are not supported\n"));
		goto finish;
	}

	if (header.imageTypeCode != 2)
	{
		TRACE(_T("Only uncompressed true color images are supported\n"));
		goto finish;
	}

	// ignore header.colourMapOrigin
	// ignore header.colourMapLength
	// ignore header.colourMapDepth
	// ignore header.xOrigin
	// ignore header.yOrigin

	mWidth = header.width;
	mHeight = header.height;

	// check that we support all bits set in the image descriptor
	if (header.imageDescriptor & ~kTGAImageDescriptor_SupportMask)
	{
		TRACE(_T("Unsupported image descriptor.\n"));
		goto finish;
	}

	// check that we support the tga image
	if (((header.bitsPerPixel != 24) && ((header.imageDescriptor & kTGAImageDescriptor_AlphaMask) != 0)) &&
		((header.bitsPerPixel != 32) && ((header.imageDescriptor & kTGAImageDescriptor_AlphaMask) != 8)))
	{
		TRACE(_T("Only 24 bit RGB or 32 bit ARGB images are supported.\n"));
		goto finish;
	}

	mBitsPerPixel = header.bitsPerPixel;
	mImageDescriptorFlags = header.imageDescriptor;

	// seek to the end of the file to determine file size
	result = fseek(file, 0, SEEK_END);
	if (result != 0)
	{
		TRACE(_T("Could not seek file\n"));
		goto finish;
	}

	// seek to the optional footer
	result = fseek(file, -(int)sizeof(TGAFooter), SEEK_END);
	if (result == 0)
	{
		// We need to load the data where we expect the footer to be
		// in order to determine if it is a footer.
		if (fread(&footer, 1, sizeof(footer), file) != sizeof(footer))
		{
			TRACE(_T("Could not read footer\n"));
			goto finish;
		}

		// check the signature and end of file is expected
		if ((strncmp(footer.signature, "TRUEVISION-XFILE", sizeof(footer.signature)) == 0) && 
			((footer.eof[0] == '.') && (footer.eof[1] == 0)))
		{
			// a valid footer has been detected

			if (footer.extensionOffset != 0)
			{
				TRACE(_T("Extension data is unsupported\n"));
				goto finish;
			}

			if (footer.developerOffset != 0)
			{
				TRACE(_T("Developer data is unsupported\n"));
				goto finish;
			}

			hasFooter = TRUE;
		}
	}

	// we are ready to load the image data, seek past the header
	result = fseek(file, sizeof(header), SEEK_SET);
	if (result != 0)
	{
		TRACE(_T("Could not seek file\n"));
		goto finish;
	}

	// seek to the end of the file to determine file size
	result = fseek(file, 0, SEEK_END);
	if (result != 0)
	{
		TRACE(_T("Could not seek file\n"));
		goto finish;
	}

	// get file size
	fileSize = ftell(file);

	// determine image data size
	mImageDataSize = fileSize - sizeof(header);
	if (hasFooter)
		mImageDataSize -= sizeof(footer);

	// we are ready to load the image data, seek past the header
	result = fseek(file, sizeof(header), SEEK_SET);
	if (result != 0)
	{
		TRACE(_T("Could not seek file\n"));
		goto finish;
	}

	// allocate memory for the image data
	try 
	{
		mImageData = new unsigned char[mImageDataSize]; 
	}
	catch (std::bad_alloc&)
	{
		// For simplicity, we do not handle all exceptions in this example,
		// however we recommend that all developers handle exceptions.
		TRACE(_T("Could not allocate memory for image data\n"));
		goto finish;
	}

	// load the image data
	if (fread(mImageData, 1, mImageDataSize, file) != mImageDataSize)
	{
		TRACE(_T("Could not read image data\n"));
		goto finish;
	}

	mValid = TRUE;

finish:
	if (! mValid)
	{
		// we failed to load and parse the TGA file
		delete mImageData;
		mImageData = NULL;
		mImageDataSize = 0;
		mWidth = 0;
		mHeight = 0;
		mBitsPerPixel = 0;
		mImageDescriptorFlags = 0;
	}

	// close file
	if (file)
		fclose(file);
}

TGALoader::~TGALoader()
{
	delete mImageData;
}

BOOL TGALoader::valid()
{
	return mValid;
}

void* TGALoader::imageData()
{
	return mImageData;
}

int TGALoader::imageDataSize()
{
	return mImageDataSize;
}

int TGALoader::width()
{
	return mWidth;
}

int TGALoader::height()
{
	return mHeight;
}

int TGALoader::bitsPerPixel()
{
	return mBitsPerPixel;
}

int TGALoader::imageDescriptorFlags()
{
	return mImageDescriptorFlags;
}
