/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "BMDSwitcherAPI.h"
#include <cstdio>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include <conio.h>
#include <comutil.h>
#include <atlbase.h>

#pragma comment(lib, "comsuppw.lib")


static const std::map<BMDSwitcherConnectToFailure, std::string> kConnectFailReasonCodes =
{
	{ bmdSwitcherConnectToFailureNoResponse,			"No response" },
	{ bmdSwitcherConnectToFailureIncompatibleFirmware,	"Incompatible firmware" },
	{ bmdSwitcherConnectToFailureCorruptData,			"Corrupt data" },
	{ bmdSwitcherConnectToFailureStateSync,				"State synchronisation failed" },
	{ bmdSwitcherConnectToFailureStateSyncTimedOut,		"State synchronisation timed-out" },
};

static const std::map<BMDSwitcherVideoMode, std::string> kSwitcherVideoModes =
{
	{ bmdSwitcherVideoMode525i5994NTSC,			"525i59.94 NTSC"},
	{ bmdSwitcherVideoMode625i50PAL,			"625i50 PAL"},
	{ bmdSwitcherVideoMode525i5994Anamorphic,	"525i59.94 Anamorphic"},
	{ bmdSwitcherVideoMode625i50Anamorphic,		"625i50 Anamorphic"},
	{ bmdSwitcherVideoMode720p50,				"HD 720p50"},
	{ bmdSwitcherVideoMode720p5994,				"HD 720p59.94"},
	{ bmdSwitcherVideoMode1080i50,				"HD 1080i50"},
	{ bmdSwitcherVideoMode1080i5994,			"HD 1080i59.94"},
	{ bmdSwitcherVideoMode1080p2398,			"HD 1080p23.98"},
	{ bmdSwitcherVideoMode1080p24,				"HD 1080p24"},
	{ bmdSwitcherVideoMode1080p25,				"HD 1080p25"},
	{ bmdSwitcherVideoMode1080p2997,			"HD 1080p29.97"},
	{ bmdSwitcherVideoMode1080p50,				"HD 1080p50"},
	{ bmdSwitcherVideoMode1080p5994,			"HD 1080p59.94"},
	{ bmdSwitcherVideoMode4KHDp2398,			"UHD 2160p23.98"},
	{ bmdSwitcherVideoMode4KHDp24,				"UHD 2160p24"},
	{ bmdSwitcherVideoMode4KHDp25,				"UHD 2160p25"},
	{ bmdSwitcherVideoMode4KHDp2997,			"UHD 2160p29.97"},
	{ bmdSwitcherVideoMode4KHDp50,				"UHD 2160p50"},
	{ bmdSwitcherVideoMode4KHDp5994,			"UHD 2160p59.94"},
	{ bmdSwitcherVideoMode8KHDp2398,			"UHD 4320p23.98"},
	{ bmdSwitcherVideoMode8KHDp24,				"UHD 4320p24"},
	{ bmdSwitcherVideoMode8KHDp25,				"UHD 4320p25"},
	{ bmdSwitcherVideoMode8KHDp2997,			"UHD 4320p29.97"},
	{ bmdSwitcherVideoMode8KHDp50,				"UHD 4320p50"},
	{ bmdSwitcherVideoMode8KHDp5994,			"UHD 4320p59.94"},
};

static const std::map<BMDSwitcherPortType, std::string> kSwitcherPortTypes =
{
	{ bmdSwitcherPortTypeExternal,				"External" },
	{ bmdSwitcherPortTypeBlack,					"Black Video" },
	{ bmdSwitcherPortTypeColorBars,				"Color-Bars" },
	{ bmdSwitcherPortTypeColorGenerator,		"Color Generator" },
	{ bmdSwitcherPortTypeMediaPlayerFill,		"Media-Player Fill" },
	{ bmdSwitcherPortTypeMediaPlayerCut,		"Media-Player Cut" },
	{ bmdSwitcherPortTypeSuperSource,			"Super-Source" },
	{ bmdSwitcherPortTypeMixEffectBlockOutput,	"Mix-Effect Block Output" },
	{ bmdSwitcherPortTypeAuxOutput,				"Auxiliary Output" },
	{ bmdSwitcherPortTypeKeyCutOutput,			"Key Cut Output" },
};

static const std::vector<std::pair<GUID, std::string>> kSwitcherTransitionStyles =
{
	std::make_pair(__uuidof(IBMDSwitcherTransitionMixParameters),		"Mix"),
	std::make_pair(__uuidof(IBMDSwitcherTransitionDipParameters),		"Dip"),
	std::make_pair(__uuidof(IBMDSwitcherTransitionWipeParameters),		"Wipe"),
	std::make_pair(__uuidof(IBMDSwitcherTransitionDVEParameters),		"DVE"),
	std::make_pair(__uuidof(IBMDSwitcherTransitionStingerParameters),	"Stinger"),
};

static const std::map<BMDSwitcherExternalPortType, std::string> kSwitcherExternalPortTypes =
{
	{ bmdSwitcherExternalPortTypeSDI,			"SDI" },
	{ bmdSwitcherExternalPortTypeHDMI,			"HDMI" },
	{ bmdSwitcherExternalPortTypeComponent,		"Component" },
	{ bmdSwitcherExternalPortTypeComposite,		"Composite" },
	{ bmdSwitcherExternalPortTypeSVideo,		"S-Video" },
	{ bmdSwitcherExternalPortTypeXLR,			"XLR Audio" },
	{ bmdSwitcherExternalPortTypeAESEBU,		"AES EBU Audio" },
	{ bmdSwitcherExternalPortTypeRCA,			"RCA Audio" },
	{ bmdSwitcherExternalPortTypeInternal,		"Internal" },
	{ bmdSwitcherExternalPortTypeTSJack,		"TS Jack" },
	{ bmdSwitcherExternalPortTypeMADI,			"MADI" },
	{ bmdSwitcherExternalPortTypeTRS,			"TRS" },
};

static const std::map<BMDSwitcherAudioInputType, std::string> kSwitcherAudioInputTypes =
{
	{ bmdSwitcherAudioInputTypeEmbeddedWithVideo,	"Embedded with Video" },
	{ bmdSwitcherAudioInputTypeMediaPlayer,			"Media Player" },
	{ bmdSwitcherAudioInputTypeAudioIn,				"Audio input" },
};

static const std::map<BMDSwitcherFairlightAudioInputType, std::string> kSwitcherFairlightAudioInputTypes =
{
	{ bmdSwitcherFairlightAudioInputTypeEmbeddedWithVideo,	"Embedded with Video" },
	{ bmdSwitcherFairlightAudioInputTypeMediaPlayer,		"Media Player" },
	{ bmdSwitcherFairlightAudioInputTypeAudioIn,			"Audio input" },
	{ bmdSwitcherFairlightAudioInputTypeMADI,				"MADI input" },
};

static const std::vector<BMDSwitcherInputAvailability> kSwitcherInputAvailabilty =
{
	bmdSwitcherInputAvailabilityMixEffectBlock0,
	bmdSwitcherInputAvailabilityMixEffectBlock1,
	bmdSwitcherInputAvailabilityMixEffectBlock2,
	bmdSwitcherInputAvailabilityMixEffectBlock3,
	bmdSwitcherInputAvailabilityAuxOutputs,
	bmdSwitcherInputAvailabilityMultiView,
	bmdSwitcherInputAvailabilitySuperSourceArt,
	bmdSwitcherInputAvailabilitySuperSourceBox,
	bmdSwitcherInputAvailabilityInputCut,
};

void						get_switcher_inputs(const CComPtr<IBMDSwitcher>& switcher, std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs);
void						get_switcher_mix_effect_blocks(const CComPtr<IBMDSwitcher>& switcher, std::vector<CComPtr<IBMDSwitcherMixEffectBlock>>& mixEffectBlocks);

std::string					get_product_name(const CComPtr<IBMDSwitcher>& switcher);
int							get_usk_count_for_meb(const CComPtr<IBMDSwitcherMixEffectBlock>& mixEffectBlock);
std::vector<std::string>	get_transition_styles_for_meb(const CComPtr<IBMDSwitcherMixEffectBlock>& mixEffectBlock);
int							get_downstream_keyer_count(const CComPtr<IBMDSwitcher>& switcher);
int							get_input_type_count(const std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs, BMDSwitcherPortType portType);
int							get_media_pool_clip_count(const CComPtr<IBMDSwitcherMediaPool>& mediaPool);
int							get_media_pool_stills_count(const CComPtr<IBMDSwitcherStills>& stills);

bool						does_support_advanced_chroma_keyers(const std::vector<CComPtr<IBMDSwitcherMixEffectBlock>>& mixEffectBlocks);

void						print_supported_video_modes(const CComPtr<IBMDSwitcher>& switcher);
void						print_switcher_inputs(const std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs);
void						print_input_availability_matrix(const std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs, int mixEffectCount);
void						print_fairlight_audio_inputs(const CComPtr<IBMDSwitcherFairlightAudioMixer>& fairlightAudioMixer, std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs);
void						print_audio_inputs(const CComPtr<IBMDSwitcherAudioMixer>& audioMixer, std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs);
void						print_media_pool_stills(const CComPtr<IBMDSwitcherStills>& stills);
void						print_media_pool_clips(const CComPtr<IBMDSwitcherMediaPool>& mediaPool);


const char* BSTRToCString(const CComBSTR& str)
{
	_bstr_t bstr(str);
	const size_t newSize = (bstr.length() + 1) * 2;
	char *retString = new char[newSize];

	strcpy_s(retString, newSize, (char *)bstr);

	return retString;
}

template<typename T>
std::string LookupString(const std::map<T, std::string>& stringMap, T index)
{
	std::string connectFailReasonStr;
	auto iter = stringMap.find(index);
	
	if (iter != stringMap.end())
		return iter->second;
	else
		return "Unknown";
}


bool DeviceInfo(const char* ipAddress)
{
	CComPtr<IBMDSwitcherDiscovery>						switcherDiscovery;
	CComPtr<IBMDSwitcher>								switcher;
	std::vector<CComPtr<IBMDSwitcherInput>>				switcherInputs;
	std::vector<CComPtr<IBMDSwitcherMixEffectBlock>>	switcherMixEffectBlocks;
	CComQIPtr<IBMDSwitcherMediaPool>					switcherMediaPool;
	CComPtr<IBMDSwitcherStills>							switcherStills;
	CComQIPtr<IBMDSwitcherFairlightAudioMixer>			fairlightAudioMixer;
	std::string											productName;

	BMDSwitcherConnectToFailure							connectToFailReason;
	HRESULT												result;

	// Create an IBMDSwitcherDiscovery object to access switcher device
	result = switcherDiscovery.CoCreateInstance(CLSID_CBMDSwitcherDiscovery, NULL, CLSCTX_ALL);
	if (result != S_OK)
	{
		fprintf(stderr, "A Switcher Discovery instance could not be created.  The Switcher drivers may not be installed.\n");
		return false;
	}

	// Connect to switcher with address provided by argv
	CComBSTR addressString = _com_util::ConvertStringToBSTR(ipAddress);
	result = switcherDiscovery->ConnectTo(addressString, &switcher, &connectToFailReason);
	if (result != S_OK)
	{
		std::string connectFailReasonStr = LookupString<BMDSwitcherConnectToFailure>(kConnectFailReasonCodes, connectToFailReason);
		fprintf(stderr, "Failed to connect to switcher at address %s, reason = %s\n", ipAddress, connectFailReasonStr.c_str());
		return false;
	}
	::SysFreeString(addressString);

	// Print switcher product name
	printf("Switcher found at %s\n", ipAddress);
	productName = get_product_name(switcher);
	printf(" %-40s %s\n", "Product Name:", productName.c_str());

	// Print current and MultiView video modes
	BMDSwitcherVideoMode currentVideoMode;
	if (switcher->GetVideoMode(&currentVideoMode) == S_OK)
	{
		std::string currentVideoModeStr = LookupString<BMDSwitcherVideoMode>(kSwitcherVideoModes, currentVideoMode);
		printf(" %-40s %s\n", "Current Video Mode:", currentVideoModeStr.c_str());

		BMDSwitcherVideoMode multiViewVideoMode;
		if (switcher->GetMultiViewVideoMode(currentVideoMode, &multiViewVideoMode) == S_OK)
		{
			std::string multiViewVideoModeStr = LookupString<BMDSwitcherVideoMode>(kSwitcherVideoModes, multiViewVideoMode);
			printf(" %-40s %s\n", "MultiView Video Mode:", multiViewVideoModeStr.c_str());
		}
	}

	// Print the power status of switcher
	BMDSwitcherPowerStatus powerStatus;
	if (switcher->GetPowerStatus(&powerStatus) == S_OK)
	{
		printf(" %-40s %s\n", "Power Supply 1:", powerStatus & bmdSwitcherPowerStatusSupply1 ? "Powered" : "Not powered");
		printf(" %-40s %s\n", "Power Supply 2:", powerStatus & bmdSwitcherPowerStatusSupply2 ? "Powered" : "Not powered");
	}

	// Print whether Fairlight or original audio mixer
	fairlightAudioMixer = switcher;
	printf(" %-40s %s\n", "Audio Mixer:", fairlightAudioMixer ? "Fairlight" : "Original");

	// Print Mix Effect block count
	get_switcher_mix_effect_blocks(switcher, switcherMixEffectBlocks);
	printf(" %-40s %d\n", "Number of Mix Effect Blocks:", (int)switcherMixEffectBlocks.size());

	for (unsigned int i = 0; i < switcherMixEffectBlocks.size(); i++)
	{
		printf(" - Number of Upstream Keyers for ME%d:     %d\n", i, get_usk_count_for_meb(switcherMixEffectBlocks[i]));
		printf(" - Transition Styles supported by ME%d:    ", i);
		for (auto& transitionStyleStr : get_transition_styles_for_meb(switcherMixEffectBlocks[i]))
			printf("%s ", transitionStyleStr.c_str());
		printf("\n");
	}

	printf(" %-40s %s\n", "Supports Advanced Chroma Keyers:", does_support_advanced_chroma_keyers(switcherMixEffectBlocks) ? "Yes" : "No");
	printf(" %-40s %d\n", "Number of Downstream Keyers", get_downstream_keyer_count(switcher));

	// Print swicther input type counts
	get_switcher_inputs(switcher, switcherInputs);
	printf(" %-40s %d\n", "Number of External Inputs:", get_input_type_count(switcherInputs, bmdSwitcherPortTypeExternal));
	printf(" %-40s %d\n", "Number of SuperSources:", get_input_type_count(switcherInputs, bmdSwitcherPortTypeSuperSource));
	printf(" %-40s %d\n", "Number of Media Players:", get_input_type_count(switcherInputs, bmdSwitcherPortTypeMediaPlayerFill));
	printf(" %-40s %d\n", "Number of AUX Outputs:", get_input_type_count(switcherInputs, bmdSwitcherPortTypeAuxOutput));

	// Get Switcher Media pool.
	switcherMediaPool = switcher;
	if (switcherMediaPool)
	{
		// Get Switcher stills interfaceobject
		if (switcherMediaPool->GetStills(&switcherStills) == S_OK)
		{
			printf(" %-40s %u\n", "Number of Stills in Media Pool:", get_media_pool_stills_count(switcherStills));
		}

		printf(" %-40s %u\n", "Number of Clips in Media Pool:", get_media_pool_clip_count(switcherMediaPool));
	}

	print_supported_video_modes(switcher);
	print_switcher_inputs(switcherInputs);
	print_input_availability_matrix(switcherInputs, (int)switcherMixEffectBlocks.size());
	if (fairlightAudioMixer)
	{
		// Print Fairlight audiomixer inputs
		print_fairlight_audio_inputs(fairlightAudioMixer, switcherInputs);
	}
	else
	{
		// Print original audio mixer inputs
		CComQIPtr<IBMDSwitcherAudioMixer> audioMixer = switcher;
		if (audioMixer)
			print_audio_inputs(audioMixer, switcherInputs);
	}

	if (switcherStills)
	{
		print_media_pool_stills(switcherStills);
	}

	if (switcherMediaPool)
	{
		print_media_pool_clips(switcherMediaPool);
	}

	return true;
}

int main(int argc, char** argv)
{
	bool deviceInfoSuccess = true;
	HRESULT result;

	if (argc != 2)
	{
		fprintf(stderr, "Expected: %s <ip_address>\n", argv[0]);
		return 1;
	}
	
	// Initialize COM on this thread
	result = CoInitializeEx(NULL, NULL);
	if (FAILED(result))
	{
		fprintf(stderr, "Initialization of COM failed - result = %08x\n", result);
		return 1;
	}

	deviceInfoSuccess = DeviceInfo(argv[1]);

	// Wait for any key press before exiting
	(void) _getch();
	
	// Uninitalize COM on this thread
	CoUninitialize();

	return deviceInfoSuccess ? 0 : 1;
}

void get_switcher_inputs(const CComPtr<IBMDSwitcher>& switcher, std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs)
{
	CComPtr<IBMDSwitcherInputIterator> inputIterator;
	if (switcher->CreateIterator(IID_IBMDSwitcherInputIterator, (void**)&inputIterator) == S_OK)
	{
		CComPtr<IBMDSwitcherInput> input;
		while (inputIterator->Next(&input) == S_OK)
			switcherInputs.push_back(std::move(input));
	}
}

void get_switcher_mix_effect_blocks(const CComPtr<IBMDSwitcher>& switcher, std::vector<CComPtr<IBMDSwitcherMixEffectBlock>>& mixEffectBlocks)
{
	CComPtr<IBMDSwitcherMixEffectBlockIterator> mixEffectBlockIterator;
	if (switcher->CreateIterator(IID_IBMDSwitcherMixEffectBlockIterator, (void**)&mixEffectBlockIterator) == S_OK)
	{
		CComPtr<IBMDSwitcherMixEffectBlock> mixEffectBlock;
		while (mixEffectBlockIterator->Next(&mixEffectBlock) == S_OK)
			mixEffectBlocks.push_back(std::move(mixEffectBlock));
	}
}

int get_downstream_keyer_count(const CComPtr<IBMDSwitcher>& switcher)
{
	int											downstreamKeyerCount = 0;
	CComPtr<IBMDSwitcherDownstreamKeyIterator>	dskIterator;
	CComPtr<IBMDSwitcherDownstreamKey>			dsk;

	if (switcher->CreateIterator(IID_IBMDSwitcherDownstreamKeyIterator, (void**)&dskIterator) != S_OK)
		return 0;

	while (dskIterator->Next(&dsk) == S_OK)
	{
		downstreamKeyerCount++;
		dsk.Release();
	}
	
	return downstreamKeyerCount;
}

bool does_support_advanced_chroma_keyers(const std::vector<CComPtr<IBMDSwitcherMixEffectBlock>>& mixEffectBlocks)
{
	for (auto& mixEffectBlock : mixEffectBlocks)
	{
		CComPtr<IBMDSwitcherKeyIterator>	keyIterator;
		CComPtr<IBMDSwitcherKey>			keyer;

		if (mixEffectBlock->CreateIterator(IID_IBMDSwitcherKeyIterator, (void**)&keyIterator) != S_OK)
			continue;

		while (keyIterator->Next(&keyer) == S_OK)
		{
			BOOL advancedChromaSupported = FALSE;
			// Check whether advanced chroma keying is supported by switcher
			if ((keyer->DoesSupportAdvancedChroma(&advancedChromaSupported) == S_OK) && advancedChromaSupported)
				return true;

			keyer.Release();
		}
	}

	return false;
}

std::string get_product_name(const CComPtr<IBMDSwitcher>& switcher)
{
	CComBSTR productNameString;
	
	// *** Print the product name of the Switcher
	if (switcher->GetProductName(&productNameString) != S_OK)
	{
		return "N/A";
	}
	
	int wlen = ::SysStringLen(productNameString);
	int mblen = ::WideCharToMultiByte(CP_ACP, 0, (wchar_t*)productNameString, wlen, NULL, 0, NULL, NULL);

	std::string productName(mblen, '\0');
	mblen = ::WideCharToMultiByte(CP_ACP, 0, (wchar_t*)productNameString, wlen, &productName[0], mblen, NULL, NULL);

	return productName;
}

int get_usk_count_for_meb(const CComPtr<IBMDSwitcherMixEffectBlock>& mixEffectBlock)
{
	int									upstreamKeyerCount = 0;
	CComPtr<IBMDSwitcherKeyIterator>	keyIterator;
	CComPtr<IBMDSwitcherKey>			keyer;

	if (mixEffectBlock->CreateIterator(IID_IBMDSwitcherKeyIterator, (void**)&keyIterator) != S_OK)
		return 0;

	while (keyIterator->Next(&keyer) == S_OK)
	{
		upstreamKeyerCount++;
		keyer.Release();
	}
	
	return upstreamKeyerCount;
}

std::vector<std::string> get_transition_styles_for_meb(const CComPtr<IBMDSwitcherMixEffectBlock>& mixEffectBlock)
{
	std::vector<std::string>	supportedStyles;
	
	for (auto& transitionStyle: kSwitcherTransitionStyles)
	{
		CComPtr<IUnknown> transitionParameters;
		
		if (mixEffectBlock->QueryInterface(transitionStyle.first, (void**)&transitionParameters) == S_OK)
			supportedStyles.push_back(transitionStyle.second);
	}
	
	return supportedStyles;
}

int get_input_type_count(const std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs, BMDSwitcherPortType portType)
{
	int portCount = 0;

	for (auto& input : switcherInputs)
	{
		BMDSwitcherPortType type;
		if ((input->GetPortType(&type) == S_OK) && (type == portType))
			portCount++;
	}
	
	return portCount;
}

int get_media_pool_clip_count(const CComPtr<IBMDSwitcherMediaPool>& mediaPool)
{
	unsigned int	clipCount;
	int				validClipCount = 0;
	
	if (mediaPool->GetClipCount(&clipCount) != S_OK)
		return 0;

	for (unsigned int i = 0; i < clipCount; i++)
	{
		// Count only clips marked as valid
		CComPtr<IBMDSwitcherClip> clip;
		if (mediaPool->GetClip(i, &clip) == S_OK)
		{
			BOOL isValid;
			if ((clip->IsValid(&isValid) == S_OK) && isValid)
				validClipCount++;
		}
	}

	return validClipCount;
}

int get_media_pool_stills_count(const CComPtr<IBMDSwitcherStills>& stills)
{
	unsigned int	stillsCount;
	int				validStillsCount = 0;
	
	if (stills->GetCount(&stillsCount) != S_OK)
		return 0;

	for (unsigned int i = 0; i < stillsCount; i++)
	{
		// Count only stills marked as valid
		BOOL isValid;
		if ((stills->IsValid(i, &isValid) == S_OK) && isValid)
			validStillsCount++;
	}

	return validStillsCount;
}

void print_supported_video_modes(const CComPtr<IBMDSwitcher>& switcher)
{
	printf("\nSwitcher Video Mode Support:\n");
	printf(" %-25s%-35s%s\n", "Video Mode", "HD Down Converted Video Mode", "MultiView Video Mode");

	for (auto& mode : kSwitcherVideoModes)
	{
		BOOL videoModeSupported;
		BMDSwitcherVideoMode hdDownConvertedVideoMode;
		BMDSwitcherVideoMode multiViewVideoMode;
		std::string hdDownConvertedVideoModeStr = "-----";
		std::string multiViewVideoModeStr = "-----";

		if ((switcher->DoesSupportVideoMode(mode.first, &videoModeSupported) != S_OK) || !videoModeSupported)
			continue;

		if (switcher->GetDownConvertedHDVideoMode(mode.first, &hdDownConvertedVideoMode) == S_OK)
			hdDownConvertedVideoModeStr = LookupString<BMDSwitcherVideoMode>(kSwitcherVideoModes, hdDownConvertedVideoMode);
			
		if (switcher->GetMultiViewVideoMode(mode.first, &multiViewVideoMode) == S_OK)
			multiViewVideoModeStr = LookupString<BMDSwitcherVideoMode>(kSwitcherVideoModes, multiViewVideoMode);
			
		printf(" %-25s%-35s%s\n", mode.second.c_str(), hdDownConvertedVideoModeStr.c_str(), multiViewVideoModeStr.c_str());
	}
}

void print_switcher_inputs(const std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs)
{
	printf("\nSwitcher Inputs:\n");
	printf(" %-7s%-12s%-22s%s\n", "ID", "Short Name", "Long Name", "Type");
	for (auto& input : switcherInputs)
	{
		BMDSwitcherPortType portType;
		BMDSwitcherInputId inputId;
		BSTR longName[21];
		BSTR shortName[5];
		BMDSwitcherExternalPortType externalPortType;
		std::string portTypeStr;

		if (input->GetPortType(&portType) != S_OK)
			continue;
		
		if (input->GetInputId(&inputId) != S_OK)
			continue;
		
		if (input->GetShortName(shortName) != S_OK)
			continue;
		
		if (input->GetLongName(longName) != S_OK)
			continue;
		
		if ((portType == bmdSwitcherPortTypeExternal) && (input->GetCurrentExternalPortType(&externalPortType) != S_OK))
			continue;
		
		portTypeStr = LookupString<BMDSwitcherPortType>(kSwitcherPortTypes, portType);
		
		printf(" %-7lld%-12s%-22s%s",
			   inputId,
			   BSTRToCString(*shortName),
			   BSTRToCString(*longName),
			   portTypeStr.c_str());

		if (portType == bmdSwitcherPortTypeExternal)
			printf(" (%s)", LookupString<BMDSwitcherExternalPortType>(kSwitcherExternalPortTypes, externalPortType).c_str());

		printf("\n");
	}
}

void print_input_availability_matrix(const std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs, int mixEffectCount)
{
	printf("\nSwitcher Input Availability Matrix:\n");
	printf(" %-7s", "Input");
	for (int i = 0; i < mixEffectCount; i++)
		printf( "ME%d  ", i);
	printf("AUX  MV   SSA  SSB  CUT\n");

	for (auto& input : switcherInputs)
	{
		BMDSwitcherInputAvailability	inputAvailability;
		BSTR							shortName[5];

		if (input->GetInputAvailability(&inputAvailability) != S_OK)
			continue;

		if (input->GetShortName(shortName) != S_OK)
			continue;

		printf(" %-7s", BSTRToCString(*shortName));
			
		for (auto availability : kSwitcherInputAvailabilty)
		{
			if (((mixEffectCount < 2) && (availability == bmdSwitcherInputAvailabilityMixEffectBlock1)) ||
				((mixEffectCount < 3) && (availability == bmdSwitcherInputAvailabilityMixEffectBlock2)) ||
				((mixEffectCount < 4) && (availability == bmdSwitcherInputAvailabilityMixEffectBlock3)))
			{
				continue;
			}
			printf(" %s   ", (availability & inputAvailability) ? "*" : "-");
		}
		printf("\n");
	}
}

void print_fairlight_audio_inputs(const CComPtr<IBMDSwitcherFairlightAudioMixer>& fairlightAudioMixer, std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs)
{
	BMDSwitcherInputId									mediaPlayerTargetId = 0;
	CComPtr<IBMDSwitcherFairlightAudioInputIterator>	fairlightAudioInputIterator;
	CComPtr<IBMDSwitcherFairlightAudioInput>			fairlightAudioInput;

	printf("\nFairlight Audio Mixer Inputs:\n");
	printf(" %-7s%s\n", "ID", "Type");
	
	if (fairlightAudioMixer->CreateIterator(IID_IBMDSwitcherFairlightAudioInputIterator, (void**)&fairlightAudioInputIterator) != S_OK)
		return;

	while (fairlightAudioInputIterator->Next(&fairlightAudioInput) == S_OK)
	{
		BMDSwitcherFairlightAudioInputType inputType;
		BMDSwitcherAudioInputId inputId;
		BMDSwitcherExternalPortType externalPortType;
		std::string inputTypeStr;
		std::string externalPortTypeStr;

		if (fairlightAudioInput->GetType(&inputType) != S_OK)
			continue;
		
		if (fairlightAudioInput->GetId(&inputId) != S_OK)
			continue;
		
		if (fairlightAudioInput->GetCurrentExternalPortType(&externalPortType) != S_OK)
			continue;

		inputTypeStr = LookupString<BMDSwitcherFairlightAudioInputType>(kSwitcherFairlightAudioInputTypes, inputType);
		externalPortTypeStr = LookupString<BMDSwitcherExternalPortType>(kSwitcherExternalPortTypes, externalPortType);
			
		printf(" %-7lld%s (%s",
				inputId,
				inputTypeStr.c_str(),
				externalPortTypeStr.c_str());
		if (inputType == bmdSwitcherFairlightAudioInputTypeEmbeddedWithVideo)
		{
			// Display the short name of the corresponding switcher input
			CComQIPtr<IBMDSwitcherInput> switcherInput = fairlightAudioInput;
			if (switcherInput)
			{
				BSTR inputShortName[5];
				if (switcherInput->GetShortName(inputShortName) == S_OK)
					printf(" - %s", BSTRToCString(*inputShortName));
			}
		}
		else if (inputType == bmdSwitcherFairlightAudioInputTypeMediaPlayer)
		{
			// Cycle through switcher inputs and match port type with Media Player Fill
			for (auto& switcherInput : switcherInputs)
			{
				BMDSwitcherPortType portType;
				BMDSwitcherInputId inputId;
				if ((switcherInput->GetPortType(&portType) == S_OK) &&
					(portType == bmdSwitcherPortTypeMediaPlayerFill) &&
					(switcherInput->GetInputId(&inputId) == S_OK) &&
					(inputId >= mediaPlayerTargetId))
				{
					BSTR inputShortName[5];
					if (switcherInput->GetShortName(inputShortName) == S_OK)
						printf(" - %s", BSTRToCString(*inputShortName));
					mediaPlayerTargetId = inputId + 1;
					break;
				}
			}
		}
		
		printf(")\n");

		fairlightAudioInput.Release();
	}
}

void print_audio_inputs(const CComPtr<IBMDSwitcherAudioMixer>& audioMixer, std::vector<CComPtr<IBMDSwitcherInput>>& switcherInputs)
{
	BMDSwitcherInputId							mediaPlayerTargetId = 0;
	CComPtr<IBMDSwitcherAudioInputIterator>		audioInputIterator;
	CComPtr<IBMDSwitcherAudioInput>				audioInput;

	printf("\nAudio Mixer Inputs:\n");
	printf(" %-7s%s\n", "ID", "Type");

	if (audioMixer->CreateIterator(IID_IBMDSwitcherAudioInputIterator, (void**)&audioInputIterator) != S_OK)
		return;

	while (audioInputIterator->Next(&audioInput) == S_OK)
	{
		BMDSwitcherAudioInputType inputType;
		BMDSwitcherAudioInputId inputId;
		BMDSwitcherExternalPortType externalPortType;
		std::string inputTypeStr;
		std::string externalPortTypeStr;
			
		if (audioInput->GetType(&inputType) != S_OK)
			continue;
		
		if (audioInput->GetAudioInputId(&inputId) != S_OK)
			continue;
		
		if (audioInput->GetCurrentExternalPortType(&externalPortType) != S_OK)
			continue;
		
		inputTypeStr = LookupString<BMDSwitcherAudioInputType>(kSwitcherAudioInputTypes, inputType);
		externalPortTypeStr = LookupString<BMDSwitcherExternalPortType>(kSwitcherExternalPortTypes, externalPortType);

		printf(" %-7lld%s (%s",
				inputId,
				inputTypeStr.c_str(),
				externalPortTypeStr.c_str());
		if (inputType == bmdSwitcherAudioInputTypeEmbeddedWithVideo)
		{
			// Display the short name of the corresponding switcher input
			CComQIPtr<IBMDSwitcherInput> switcherInput = audioInput;
			if (switcherInput)
			{
				BSTR inputShortName[5];
				if (switcherInput->GetShortName(inputShortName) == S_OK)
					printf(" - %s", BSTRToCString(*inputShortName));
			}
		}
		else if (inputType == bmdSwitcherAudioInputTypeMediaPlayer)
		{
			// Cycle through switcher inputs and match port type with Media Player Fill
			for (auto& switcherInput : switcherInputs)
			{
				BMDSwitcherPortType portType;
				BMDSwitcherInputId inputId;
				if ((switcherInput->GetPortType(&portType) == S_OK) &&
					(portType == bmdSwitcherPortTypeMediaPlayerFill) &&
					(switcherInput->GetInputId(&inputId) == S_OK) &&
					(inputId >= mediaPlayerTargetId))
				{
					BSTR inputShortName[5];
					if (switcherInput->GetShortName(inputShortName) == S_OK)
						printf(" - %s", BSTRToCString(*inputShortName));
					mediaPlayerTargetId = inputId + 1;
					break;
				}
			}
		}
		
		printf(")\n");

		audioInput.Release();
	}
}

void print_media_pool_stills(const CComPtr<IBMDSwitcherStills>& stills)
{
	unsigned int stillsCount;
	printf("\nMedia Pool Stills:\n");
	printf(" %-7s%s\n", "ID", "Name");
	
	if (stills->GetCount(&stillsCount) != S_OK)
		return;
		
	for (unsigned int i = 0; i < stillsCount; i++)
	{
		BOOL isValid;
		if ((stills->IsValid(i, &isValid) == S_OK) && isValid)
		{
			CComBSTR stillName;
			if (stills->GetName(i, &stillName) == S_OK)
				printf(" %-7d%s\n", i, BSTRToCString(stillName));
		}
	}
	printf("\n");
}

void print_media_pool_clips(const CComPtr<IBMDSwitcherMediaPool>& mediaPool)
{
	unsigned int clipCount;
	printf("\nMedia Pool Clips:\n");
	printf(" %-7s%-40s%s\n", "ID", "Name", "Frame Count");
	
	if (mediaPool->GetClipCount(&clipCount) != S_OK)
		return;
	
	for (unsigned int i = 0; i < clipCount; i++)
	{
		CComPtr<IBMDSwitcherClip> clip;
		if (mediaPool->GetClip(i, &clip) == S_OK)
		{
			BOOL isValid;
			if ((clip->IsValid(&isValid) == S_OK) && isValid)
			{
				CComBSTR		clipName;
				unsigned int	clipIndex;
				unsigned int	clipFrameCount;
				if ((clip->GetName(&clipName) == S_OK) &&
					(clip->GetIndex(&clipIndex) == S_OK) &&
					(clip->GetFrameCount(&clipFrameCount) == S_OK))
					printf(" %-7d%-40s%u\n", clipIndex, BSTRToCString(clipName), clipFrameCount);
			}
		}
	}
	printf("\n");
}
